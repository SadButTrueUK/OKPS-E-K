/**
* \file    CheckRAM.c
* \brief   \copybrief CheckRAM.h
* 
* \version 2.0.1
* \date    05-07-2016
* \author  Третьяков В.Ж.
*/

//*****************************************************************************
// Подключаемые файлы
//*****************************************************************************
#include "asserts.h"
#include "ProtectionState_codes.h"
#include "CheckRAM.h"

//*****************************************************************************
// Объявление типов данных
//*****************************************************************************

//*****************************************************************************
/// \brief Структура объекта "Проверка работоспособности ОЗУ".
///
typedef struct CheckRAM_Tag
{
    uint32_t address;    ///< Текущий адрес подсчета контрольной суммы.
    bool result;         ///< Результат контроля ОЗУ.
} CheckRAM;

//*****************************************************************************
// Объявление локальных переменных
//*****************************************************************************
static CheckRAM checkRAM;    ///< Объект "Проверка работоспособности ОЗУ".

//*****************************************************************************
// Прототипы локальных функций
//*****************************************************************************

//*****************************************************************************
/// \brief Тест ячейки ОЗУ.
/// \param address – адрес ОЗУ;
/// \param data    – данные ячейки.
/// \retval true  - ячейка исправна;
/// \retval false - ячейка неисправна.
///
bool testRAMcell( uint16_t address, uint16_t data );

//*****************************************************************************
// Реализация интерфейсных функций
//*****************************************************************************

//*****************************************************************************
// Инициализация переменных модуля CheckRAM
void CheckRAM_ctor( void )
{
    checkRAM.address = RAM_START_ADDRESS;
    checkRAM.result = true;
}

//*****************************************************************************
// Проверка ОЗУ
bool CheckRAM_run( void )
{
    uint16_t i;

    checkRAM.result = true;

    for( i = 0; i < 8; i++ )
    {
        if( !testRAMcell( checkRAM.address, 0x5AA5 ) || !testRAMcell( checkRAM.address, 0xA55A ) )
        {
            checkRAM.result = false;
            ERROR_ID( eGrPS_ControlMK, ePS_ControlMkFaultRAM );
        }
        checkRAM.address += 2;
        if( checkRAM.address == RAM_END_ADDRESS )
        {
            checkRAM.address = RAM_START_ADDRESS;
        }
    }
    return checkRAM.result;
}

//*****************************************************************************
// Реализация локальных функций
//*****************************************************************************

//*****************************************************************************
// Тест ячейки ОЗУ
bool testRAMcell( uint16_t address, uint16_t data )
{
    uint16_t result;
    asm volatile
            (
              "mov    #0x0001, %0     \n\t" // Результат тестирования - норма
              "mov    [%1],    W4     \n\t" // Сохранение содержимого ячейки памяти
              "disi   #(5)            \n\t" // Запрещение прерываний
              "mov    %2,      [%1]   \n\t"
              "mov    [%1],    W3     \n\t"
              "cpseq  %2,      W3     \n\t"
              "clr    %0              \n\t" // Результат тестирования - не норма
              "mov    W4,      [%1]       " // Восстановление содержимого ячейки памяти
              :"=&r" ( result )
              :"r" ( address ), "r" ( data )
              :"w3", "w4"
              );
    return( result ) ? true : false;
}

//*****************************************************************************
/**
* История изменений:
*
* Версия 1.0.1
* Дата   05-07-2015
* Автор  Третьяков В.Ж.
*
* Изменения:
*    Базовая версия.
* 
* Версия 2.0.1
* Дата   05-07-2016
* Автор  Третьяков В.Ж.
*
* Изменения:
*    Изменения под новую схему на dsPIC33.
*/

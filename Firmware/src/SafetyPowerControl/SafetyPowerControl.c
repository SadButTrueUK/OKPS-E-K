/**
* \file    SafetyPowerControl.c
* \brief   \copybrief SafetyPowerControl.h
*
* \version 1.0.1
* \date    05-10-2018
* \author  Агулов М.А.
*/

//*****************************************************************************
// Подключаемые файлы
//*****************************************************************************
#include <string.h>
#include "typeMK.h"
#include "asserts.h"
#include "SafetyPowerControl.h"
#include "ConfigMK.h"
#include "MainRegisters.h"
#include "ProtectionState_codes.h"

//*****************************************************************************
// Локальные константы, определенные через макросы
//*****************************************************************************

//*****************************************************************************
#define KPS _RE12                          ///< Вход сигнала контроля.

//*****************************************************************************
#define SPC_TESTING_PERIOD        100      ///< Интервал между контролями исправности ключей, мс.
#define SPC_PWM_FREQ              32000    ///< Частота формирования ШИМ-сигнала, Гц.
#define SPC_CHECKUP_FAULT_TIMEOUT 600      ///< Время до ухода в ЗС в периодическом контроле каждого импульса ШИМ, мс.
#define SPC_TESTING_FAULT_TIMEOUT 600      ///< Время до ухода в ЗС при тестовом воздействии, мс.

//*****************************************************************************
#define SPC_KPS_CORRECT_STATE  0    ///< Правильное значение сигнала KPS при нормальной работе (не режим тестирования).
#define SPC_KPS_TEST_STATE     1    ///< Правильное значение сигнала KPS в режиме тестирования.
#define SPC_POWER_ON_PWM_DELAY 3    ///< Задержка выдачи ШИМ по включению, тактов ШИМ.

#if( SPC_TESTING_PERIOD < 1 || SPC_TESTING_PERIOD > 4095 )
    #error "Период между тестовыми импульсами выходит за допустимый диапазон (1...4095)"
#endif

//*****************************************************************************
// Определение локальных типизированных констант
//*****************************************************************************

//*****************************************************************************
/// \brief Время до ухода в ЗС в периодическом контроле каждого импульса ШИМ.
///
const uint16_t PeriodicCheckupFaultThreshold = SPC_CHECKUP_FAULT_TIMEOUT * 32;

//*****************************************************************************
/// \brief  Время до ухода в ЗС при тестовом воздействии.
///
const uint16_t TestingFaultThreshold = SPC_TESTING_FAULT_TIMEOUT / 100 * 2;

//*****************************************************************************
/// \brief Интервал между контролями исправности ключей.
///
const uint16_t TestingPeriod = SPC_TESTING_PERIOD * 16;

//*****************************************************************************
// Определение типов данных
//*****************************************************************************
/// \brief Идентификаторы состояний автомата состояний.
///
typedef enum 
{
    eStateNormal,    ///< режим работы нормальной генерации ШИМ
    
    //*****************************************************************************
    /// \brief режим контроля реакции на тестовое воздействие (выходы формирования ШИМ находятся в Z-состоянии)
    /// 
    eStateTest,
    eStatePwmOn,     ///< режим работы "ББП включен".
    eStatePwmOff     ///< режим работы "ББП выключен"
} SPC_StateFSM;

//*****************************************************************************
/// \brief Создание типа структуры состояния источника безопасного питания.
///
typedef struct 
{
    uint16_t     PeriodicCheckupFaultCnt;        ///< Счетчик состояний "Ошибка периодического контроля".
    uint16_t     TestingFaultCnt;                ///< Счетчик состояний "Ошибка тестового контроля".
    uint16_t     CheckCnt;                       ///< Счетчик периода тестирования.
    SPC_StateFSM State;                          ///< Состояние FSM автомата.
    uint16_t     ControlVal;                     ///< Порог счетчика тестирования.
} Spc;

//*****************************************************************************
// Определение локальных переменных
//*****************************************************************************
static Spc spc;     ///< Переменная структуры состояния источника безопасного питания.

//*****************************************************************************
// Реализация интерфейсных функций
//*****************************************************************************

//*****************************************************************************
// Инициализация компонента
void SafetyPowerControl_ctor( void )
{
    // Конфигурация пинов 
    RPOR7bits.RP57R = _RPOUT_OC1; // Источник данных для пина

    INIC_PORT_IN( E, 12, eIO_pullOff );
    
    // Конфигурация модулей захвата OC1 и OC2 - управление ключами безопасного блока питания
    OC1CON1 = OC1CON2 = 0;
    OC1CON1bits.OCTSEL = 1;
    OC1CON2bits.OCTRIS = 1;
    OC1CON2bits.SYNCSEL = 0x0D;
    OC1CON1bits.OCM = 0b110;

    memset( &spc, 0, sizeof( spc ) ); // Очистка переменных и буферов    
    spc.State = eStatePwmOn;

    if( ConfigMK_isMaster( ) )
    {
        OC1CON2bits.OCINV = 1; // Slave имеет инверсный выход
        spc.ControlVal = TestingPeriod / 2; // Контрольный импульс в Slave сдвинут по фазе на половину периода
    }
    else
    {
        OC1CON2bits.OCINV = 0;
        spc.ControlVal = TestingPeriod;
    }

    // Настройка TMR3 - источника синхронизации модулей захвата
    T3CON = 0; // Конфигурацию TMR3 проводим в состояние сброса
    TMR3 = 0;
    IFS0bits.T3IF = 0;
    PR3 = Fcy / SPC_PWM_FREQ - 4; // Установка периода ШИМа. Fpwm = 14745600 Гц * 4 / (1843 + 4) = 15965.35 Гц.
    T3CONbits.TON = 1;
    OC1R = PR3 / 2;
}

//*****************************************************************************
// Реализация формирования безопасного питания и его контроля
void SafetyPowerControl_runInterrupt( void )
{
    TMR3 = 350;         // Синхронизация таймера в Master и Slave
    // Инкремент счётчика циклов и контроль максимального значения
    spc.CheckCnt++ != TestingPeriod ? : ( spc.CheckCnt = 0 );

    switch( spc.State )
    {
        case eStateNormal: // Режим нормальной работы ББП
            CASSERT_ID( eGrPS_SafetyPowerControl, ePS_SPC_PeriodicCheckFault, // Группа и код отказа
                        spc.PeriodicCheckupFaultCnt,        // Счётчик ошибок
                        PeriodicCheckupFaultThreshold,      // Максимальное значение счётчика ошибок
                        KPS == SPC_KPS_CORRECT_STATE );     // Логическое выражение 

            if( spc.CheckCnt == spc.ControlVal )
            {
                OC1CON2bits.OCTRIS = 1; // Выход ШИМа устанавливаем в Z-состояние для контроля 
                spc.State = eStateTest;
            }
            else
                if( spc.CheckCnt == SPC_POWER_ON_PWM_DELAY ) // Задержка выдачи ШИМ по вкл. питания
                OC1CON2bits.OCTRIS = 0;
            break;

        case eStateTest: // Режим тестирования ключей ББП
            CASSERT_ID( eGrPS_SafetyPowerControl, ePS_SPC_TestCheckFault,   // Группа и код отказа
                        spc.TestingFaultCnt,                    // Счётчик ошибок
                        TestingFaultThreshold,                  // Максимальное значение счётчика ошибок
                        KPS == SPC_KPS_TEST_STATE );            // Логическое выражение 

            OC1CON2bits.OCTRIS = 0; // Выход ШИМа устанавливаем рабочее состояние
            spc.State = eStateNormal;
            break;

        case eStatePwmOn: // Режим включения ББП
            spc.CheckCnt = spc.TestingFaultCnt = spc.PeriodicCheckupFaultCnt = 0;
            spc.State = eStateNormal;
            break;

        case eStatePwmOff:                  // Режим выключенного ББП
            OC1CON2bits.OCTRIS = 1;         // Выход ШИМа устанавливаем в Z-состояние
            break;

        default:
            // Ошибка в работе автомата состояний (неизвестное состояние автомата)
            ERROR_ID( eGrPS_SafetyPowerControl, ePS_SPC_FSM_UnknownState ); 
    }
}

//*****************************************************************************
/**
* История изменений: 
* 
* Версия 1.0.1
* Дата   05-10-2018
* Автор  Агулов М.А.
* 
* Изменения:
*    Базовая версия.
*/

/**
* \file    Adc.c
* \brief   \copybrief Adc.h
* 
* \version 2.0.2
* \date    12-03-2020
* \author  Агулов М.А.
*/

//*****************************************************************************
// Подключаемые файлы
//*****************************************************************************
#include "asserts.h"
#include "AnalogInputId.h"
#include "ProtectionState_codes.h"
#include "AdcDriver_PIC33.h"
#include "Adc.h"
#include <string.h>

//*****************************************************************************
// Локальные константы, определенные через макросы
//*****************************************************************************

//*****************************************************************************
/// \brief Размер циклической очереди.
/// \details Критерием определения наличия данных в очереди служит различие
/// указателей чтения и записи.
/// \details Критерием переполнения очереди служит одинаковое значение указателей
/// поля добавления данных.
/// \note С целью обеспечения вышеуказанных критериев, очередь создается большей
/// на 1-ин элемент чем необходимо с учетом частоты дискретизации измерений
/// аналоговых сигналов.
///
#define QUEUE_SIZE (AnalogInputDrvQueueSize + 1)

//*****************************************************************************
// Объявление типов данных
//*****************************************************************************

//*****************************************************************************
/// \brief Единица данных, с которой работает очередь.
///
typedef struct tagQueueArrayData
{
    uint16_t data[eAinChCount];                     ///< Массив для хранения данных всех измерительных каналов АЦП.
} QueueArrayData;

//*****************************************************************************
/// \brief Очередь драйвера.
///
typedef struct tagQueueArray
{
    QueueArrayData *front;                          ///< Указатель записи.
    QueueArrayData *rear;                           ///< Указатель чтения.
    QueueArrayData buf[QUEUE_SIZE];                 ///< Буфер.
} QueueArray;

//*****************************************************************************
/// \brief Данные драйвера.
///
typedef struct tagAdc
{
    QueueArray queue;                               ///< Очередь драйвера.
} Adc;

//*****************************************************************************
// Объявление локальных типизированных констант
//*****************************************************************************

//*****************************************************************************
// Объявление локальных переменных
//*****************************************************************************
extern uint16_t ADCbuf[32];

static Adc adc = {.queue.front = &adc.queue.buf[0], .queue.rear = &adc.queue.buf[0]};                                   ///< Объект АЦП.

//*****************************************************************************
// Реализация интерфейсных функций
//*****************************************************************************

//*****************************************************************************
// Инициализация модуля.
void Adc_ctor( void )
{
    AdcDrv_ctor( );
}

//*****************************************************************************
// Чтение результатов измерения из очереди измерений
void Adc_get( uint16_t *array)
{
    memcpy(array, &adc.queue.rear->data[0], eAinChCount * sizeof (adc.queue.rear->data[0]));                            // Копирование результатов из очереди измерений
    
    adc.queue.rear == &adc.queue.buf[QUEUE_SIZE - 1] ? ( adc.queue.rear = &adc.queue.buf[0] ) : adc.queue.rear++;       // Смещение указателя очереди
}

//******************************************************************************
// Проверка наличия результатов измерений в очереди
bool Adc_isReady( void )
{
    return adc.queue.front != adc.queue.rear;
}

//******************************************************************************
// Управление драйвером АЦП и копирование результатов измерений в очередь измерений
void Adc_run_interrupt( void )
{
    AdcDrv_Stop( );
    
    // Копируем значения из буфера DMA в очередь АЦП
    adc.queue.front->data[eAinchR1]   = ADCbuf[0];
    adc.queue.front->data[eAinchR2]   = ADCbuf[1];
    adc.queue.front->data[eAinchK3V3] = ADCbuf[2];
    adc.queue.front->data[eAinchREF]  = ADCbuf[3];
    adc.queue.front->data[eAinchKREF] = ADCbuf[4];
    adc.queue.front->data[eAinchGEN]  = ADCbuf[5];
    adc.queue.front->data[eAinchUV]   = ADCbuf[6];
    adc.queue.front->data[eAinchIV]   = ADCbuf[7];
    adc.queue.front->data[eAinchIW]   = ADCbuf[8];
    adc.queue.front->data[eAinchIU]   = ADCbuf[9];
    adc.queue.front->data[eAinchUU]   = ADCbuf[10];
    adc.queue.front->data[eAinchUW]   = ADCbuf[11];

    AdcDrv_Start( );
    
   
    // Добавление результатов преобразований АЦП в очередь
    adc.queue.front == &adc.queue.buf[QUEUE_SIZE - 1] ? ( adc.queue.front = &adc.queue.buf[0] ) : adc.queue.front++;

    // Если после того, как мы добавили данные, указатели записи и чтения 
    // стали указывать на один и тот же элемент - произошло переполнение очереди
    ASSERT_ID( eGrPS_AdcDrv, ePS_AdcOverflow, adc.queue.front != adc.queue.rear );
}

//*****************************************************************************
/**
* История изменений:
* 
* Версия 1.0.1
* Дата   11-03-2016
* Автор  Годунок А.Н.
* 
* Изменения:
*    Базовая версия.
* 
* Версия 2.0.1
* Дата   27-03-2016
* Автор  Агулов М.А.
* 
* Изменения:
*    Изменения под компилятор хc16.
*
* Версия 2.0.2
* Дата   12-03-2020
* Автор  Агулов М.А.
*
* Изменения:
*    Откорректировано форматирование.
*/

/**
* \file    Adc.c
* \brief   \copybrief Adc.h
* 
* \version 2.0.2
* \date    12-03-2020
* \author  Годунок А.Н., Агулов М.А.
*/

//*****************************************************************************
// Подключаемые файлы
//*****************************************************************************
#include "typeMK.h"
#include "asserts.h"
#include "AnalogInputId.h"
#include "ProtectionState_codes.h"
#include "AdcDriver_PIC33.h"
#include "Adc.h"
#include <string.h>

//*****************************************************************************
// Локальные константы, определенные через макросы
//*****************************************************************************

//*****************************************************************************
/// \brief Размер циклической очереди.
/// \details Критерием определения наличия данных в очереди служит различие
/// указателей чтения и записи.
/// \details Критерием переполнения очереди служит одинаковое значение указателей
/// поля добавления данных.
/// \note С целью обеспечения вышеуказанных критериев, очередь создается большей
/// на 1-ин элемент чем необходимо с учетом частоты дискретизации измерений
/// аналоговых сигналов.
///
#define QUEUE_SIZE (AnalogInputDrvQueueSize + 1)

//*****************************************************************************
// Определение типов данных
//*****************************************************************************

//*****************************************************************************
/// \brief Единица данных, с которой работает очередь.
///
typedef struct tagQueueArrayData
{
    uint16_t data[eAinChCount];                     ///< Массив для хранения данных всех измерительных каналов АЦП.
} QueueArrayData;

//*****************************************************************************
/// \brief Очередь драйвера.
///
typedef struct tagQueueArray
{
    QueueArrayData *front;                          ///< Указатель записи.
    QueueArrayData *rear;                           ///< Указатель чтения.
    QueueArrayData buf[QUEUE_SIZE];                 ///< Буфер.
} QueueArray;

//*****************************************************************************
/// \brief Данные драйвера.
///
typedef struct tagAdc
{
    uint16_t   doneErrorCounter;                    ///< Счетчик отсутствия готовности.
    QueueArray queue;                               ///< Очередь драйвера.
} Adc;

//*****************************************************************************
// Определение локальных типизированных констант
//*****************************************************************************

//*****************************************************************************
/// \brief Допустимое количество попыток чтения данных при отсутствии готовности АЦП.
///
const uint16_t doneErrorCount = 3 * CASSERT_INC;

//*****************************************************************************
// Определение локальных переменных
//*****************************************************************************

//*****************************************************************************
static Adc adc;                                     ///< Объект АЦП.

//*****************************************************************************
// Реализация интерфейсных функций
//*****************************************************************************

//*****************************************************************************
// Инициализация модуля.
void Adc_ctor( void )
{
    adc.queue.rear  = &adc.queue.buf[0];
    adc.queue.front = &adc.queue.buf[0];
    adc.doneErrorCounter = 0;
    AdcDriver_ctor( eAdc1 );
}

//*****************************************************************************
// Чтение результатов измерения из очереди измерений
void Adc_get( uint16_t *array)
{
    ASSERT_ID( eGrPS_AdcDrv, ePS_AdcDrvSetSize, eAinChCount == eAinChCount );

    memcpy(array, &adc.queue.rear->data[0], eAinChCount * sizeof (adc.queue.rear->data[0]));                       
    
    adc.queue.rear == &adc.queue.buf[QUEUE_SIZE - 1] ? ( adc.queue.rear = &adc.queue.buf[0] ) : 
                                                         adc.queue.rear++;
}

//******************************************************************************
// Наличие результатов измерений в очереди
bool Adc_isReady( void )
{
    return adc.queue.front != adc.queue.rear;
}

//******************************************************************************
// Управление драйвером АЦП и копирование результатов измерений в очередь измерений
void Adc_run( void )
{
    uint16_t aTemp[eAinChCount];

    CASSERT_ID( eGrPS_AdcDrv, ePS_AdcDoneError,
                adc.doneErrorCounter, doneErrorCount,
                AdcDriver_isReady( eAdc1 ) );

    AdcDriver_start( eAdc1 );

    
    if( AdcDriver_isReady( eAdc1 ) )
    {
        AdcDriver_get( eAdc1, aTemp, eAinChCount );

        adc.queue.front->data[eAinchR1]   = aTemp[0];
        adc.queue.front->data[eAinchR2]   = aTemp[1];
        adc.queue.front->data[eAinchK3V3] = aTemp[2];
        adc.queue.front->data[eAinchREF]  = aTemp[3];
        adc.queue.front->data[eAinchKREF] = aTemp[4];
        adc.queue.front->data[eAinchGEN]  = aTemp[5];
        adc.queue.front->data[eAinchUV]   = aTemp[6];
        adc.queue.front->data[eAinchIV]   = aTemp[7];
        adc.queue.front->data[eAinchIW]   = aTemp[8];
        adc.queue.front->data[eAinchIU]   = aTemp[9];
        adc.queue.front->data[eAinchUU]   = aTemp[10];
        adc.queue.front->data[eAinchUW]   = aTemp[11];

        adc.queue.front == &adc.queue.buf[QUEUE_SIZE - 1] ? ( adc.queue.front = &adc.queue.buf[0] ) : 
                                                              adc.queue.front++;

        // Если после того, как мы добавили данные, указатели записи и чтения 
        // стали указывать на один и тот же элемент - произошло переполнение буфера
        ASSERT_ID( eGrPS_AdcDrv, ePS_AdcOverflow, adc.queue.front != adc.queue.rear );
    }
}

//*****************************************************************************
/**
* История изменений:
* 
* Версия 1.0.1
* Автор  Годунок А.Н.
* 
* Изменения:
*    Базовая версия.
* 
* Версия 2.0.1
* Дата   27-03-2016
* Автор  Агулов М.А.
* 
* Изменения:
*    Изменения под компилятор хc16.
*
* Версия 2.0.2
* Дата   12-03-2020
* Автор  Агулов М.А.
*
* Изменения:
*    Откорректировано форматирование.
*/

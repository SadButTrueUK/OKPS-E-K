/**
* \file    asserts.h
* \brief   Управляемые утверждения (assert)
* \details Интерфейс
* \details Утверждение (assert) — это определение, которое может быть использовано 
* в программах, написанных на языках C и C++, а также позволяет проверить
* свои предположения о программе. 
* \details Каждое утверждение содержит логическое выражение, которое, по мнению 
* разработчика, будет верным в момент выполнения. В противном случае, будет
* вызвана функция обработки исключения. Проверяя, что логическое выражение 
* на самом деле верно, утверждение (assert) подтверждает предположения 
* (ожидания) о поведении программы, увеличивая уверенность в том, что 
* программа не содержит ошибок.
* \details Директива DISABLED_ASSERT отключает проверку утверждений.
* \details Директива DEBUG_EXCEPTION отключает вызов функции перехода в 
* ЗС и включает отладочную функцию.
*
* \version 1.0.2
* \date    09-07-2018
* \author  Годунок А.Н.
*/

//*****************************************************************************
// Команды препроцессора для предотвращения повторного включения содержимого файла
//*****************************************************************************
#ifndef ASSERTS_H
#define ASSERTS_H

//*****************************************************************************
// Подключаемые файлы
//*****************************************************************************
#include <stdint.h>

//#define DISABLED_ASSERT
//*****************************************************************************
// Глобальные константы, определенные через макросы
//*****************************************************************************

//*****************************************************************************
#define ASSERT_DEF_CODE    0xFF        ///< Код отказа в случае вызова \a ASSERT или \a ERROR без идентификатора.

//*****************************************************************************
/// \brief Значение, на которое увеличивается счетчик при проверке \a CASSERT и \a CASSERT_ID.
/// \note В случае, когда проверяемое условие false.
///
#define CASSERT_INC        2

//*****************************************************************************
/// \brief Значение, на которое уменьшается счетчик при проверке \a CASSERT и \a CASSERT_ID.
/// \note В случае, когда проверяемое условие true. 
///
#define CASSERT_DEC        1

//*****************************************************************************
// Макросы типа функция
//*****************************************************************************

//*****************************************************************************
/// \brief Получение кода отказа, используя тип отказа и идентификатор.
/// \details Макрос возвращает код отказа, который в старшем байте содержит тип, а в младшем - идентификатор.
/// \param group_ - тип отказа;
/// \param id_    - идентификатор отказа.
///
#define SET_CODE_ID( group_, id_ )   ( ( ( group_ ) << 8 ) + ( ( id_ ) &0x00FF ) )

//*****************************************************************************
// Макроопределения, управляющие компиляцией
//*****************************************************************************

#ifdef DONT_SAVE_LINE_NUMBER        // Вызов функции перехода в ЗС 

    //*****************************************************************************
    // Глобальные константы, определенные через макросы
    //*****************************************************************************
    
    //*****************************************************************************
    /// \brief Заглушка номера строки исходного кода.
    /// \details В случае, когда утверждение не выполняется, в функцию обработки 
    /// исключения #sysAssertException в качестве параметра передается имя 
    /// файла и номер строки. При использовании номера строки, при смещении 
    /// утверждений на другие строки будет меняться объектный файл. 
    /// Данная заглушка используется когда изменение объектного файла
    /// не допустимо (в случае изменения комментариев или пустых строк) и номер строки функцией не используется.
    /// \note Включить заглушку можно определив в свойствах 
    /// проекта директиву \a DONT_SAVE_LINE_NUMBER. В этом случае, при 
    /// компиляции будет выдаваться предупреждение «The project is compiled 
    /// with the directive DONT_SAVE_LINE_NUMBER».
    /// \note Отключить выдачу предупреждения «The project is compiled with 
    /// the directive DONT_SAVE_LINE_NUMBER» можно определив в свойствах 
    /// проекта директиву \a IGNORE_DONT_SAVE_LINE_NUMBER_WARNING.
    ///
    #define LINE_NUMBER 0

#ifndef IGNORE_DONT_SAVE_LINE_NUMBER_WARNING
    #warning "The project is compiled with the directive DONT_SAVE_LINE_NUMBER"
#endif

#else

    //*****************************************************************************
    // Глобальные константы, определенные через макросы
    //*****************************************************************************
    
    //*****************************************************************************
    /// \brief Номер строки исходного кода, на которой расположено проверяемое 
    /// утверждение.
    /// \details В случае, когда утверждение не выполняется, в функцию обработки 
    /// исключения #sysAssertException в качестве параметра передается имя 
    /// файла и номер строки. Номер строки определяется этим макросом.
    /// \note При использовании номера строки, при смещении утверждений на 
    /// другие строки будет меняться объектный файл. 
    /// \note Отключить передачу номера строки можно определив в свойствах 
    /// проекта директиву \a DONT_SAVE_LINE_NUMBER. В этом случае, при 
    /// компиляции будет выдаваться предупреждение «The project is compiled 
    /// with the directive DONT_SAVE_LINE_NUMBER».
    /// \note Отключить выдачу предупреждения «The project is compiled with 
    /// the directive DONT_SAVE_LINE_NUMBER» можно определив в свойствах 
    /// проекта директиву \a IGNORE_DONT_SAVE_LINE_NUMBER_WARNING.
    ///
    #define LINE_NUMBER __LINE__

#endif

//*****************************************************************************
/* Если определено DISABLED_ASSERT - проверка исключений отключена, макросы пустые */
#ifdef DISABLED_ASSERT   

    #warning "The project is compiled with the directive DISABLED_ASSERT"
    
    //*****************************************************************************
    // Макросы типа функция
    //*****************************************************************************
    
    //*****************************************************************************
    #define ERROR_ID( group_, id_ )                                ( ( void )0 )
    #define ERROR( )                                               ( ( void )0 )
    #define ASSERT_ID( group_, id_, test_ )                        ( ( void )0 )
    #define ASSERT( test_ )                                        ( ( void )0 )
    
    //*****************************************************************************
    #define CASSERT_ID( group_, id_, counter_, maxcount_, test_ )  ( ( void )0 )
    #define CASSERT( counter_, maxcount_, test_ )                  ( ( void )0 )
    
    //*****************************************************************************
    #define DERROR_ID( group_, id_ )                               ( ( void )0 )
    #define DERROR( )                                              ( ( void )0 )
    #define DASSERT_ID( group_, id_, test_ )                       ( ( void )0 )
    #define DASSERT( test_ )                                       ( ( void )0 )
    #define DCASSERT_ID( group_, id_, counter_, maxcount_, test_ ) ( ( void )0 )
    #define DCASSERT( counter_, maxcount_, test_ )                 ( ( void )0 )

#else  // Если ENABLED_ASSERT не определена проверка утверждений разрешена

    //*****************************************************************************
    // Макросы типа функция
    //*****************************************************************************
    
    //*****************************************************************************
    /// \brief Ошибка, с использованием типа и идентификатора.
    /// \details Макрос проверяет вызов функции #sysAssertException. 
    /// \note В функцию #sysAssertException в параметрах передаются имя файла, 
    /// в котором проверялось утверждение и номер строки с неправильным утверждением.
    /// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения 
    /// не выполняется.
    /// \param group_ - тип отказа;
    /// \param id_    - идентификатор отказа.
    ///
    
    //*****************************************************************************
    #define ERROR_ID( group_, id_ ) \
              sysAssertException( __FILE__, LINE_NUMBER, ( group_ ), ( id_ ) )
    
    /// \brief Ошибка.
    /// \details Макрос вызывает #ERROR_ID c
    /// параметрами \a group_ и \a id_, равными #ASSERT_DEF_CODE.
    /// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения 
    /// не выполняется.
    ///
    #define ERROR( )    ERROR_ID( ASSERT_DEF_CODE, ASSERT_DEF_CODE )
    
    //*****************************************************************************
    /// \brief Проверка утверждения с использованием типа и идентификатора
    /// исключения.
    /// \details Макрос проверяет, что условие \a test_ выполняется.
    /// \details Если аргумент \a test_ имеет значение false, вызывается макрос #ERROR_ID. 
    /// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения 
    /// не выполняется.
    /// \param group_ - тип отказа;
    /// \param id_    - идентификатор отказа;
    /// \param test_  - проверяемое условие.
    ///
    #define ASSERT_ID( group_, id_, test_ )                        \
        do                                                         \
        {                                                          \
            if( !( test_ ) )                                       \
            {                                                      \
                ERROR_ID( ( group_ ), ( id_ ) );                   \
            }                                                      \
        } while( 0 )
    
    //*****************************************************************************
    /// \brief Проверка утверждения.
    /// \details Макрос вызывает #ASSERT_ID c
    /// параметрами \a group_ и \a id_, равными #ASSERT_DEF_CODE.
    /// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения 
    /// не выполняется.
    /// \param test_ - проверяемое условие.
    ///
    #define ASSERT( test_ ) ASSERT_ID( ASSERT_DEF_CODE, ASSERT_DEF_CODE, test_ ) 
    
    //*****************************************************************************
    /// \brief Проверка утверждения со счетчиком, с использованием типа 
    /// и идентификатора исключения.
    /// \details Макрос проверяет, что условие \a test_ выполняется. 
    /// \note Если аргумент \a test_ имеет значение false, счетчик \a counter_ увеличивается на
    /// величину #CASSERT_INC. 
    /// \note Если счетчик достиг или превысил значение
    /// \a maxcount_, вызывается макрос #ERROR_ID.
    /// \note Если аргумент \a test_ имеет значение true, счетчик \a counter_
    /// уменьшается на величину #CASSERT_DEC до нуля. 
    /// \note Инициализацию счетчика начальным значением должен 
    /// выполнить пользователь.
    /// \param group_    - тип отказа;
    /// \param id_       - идентификатор отказа;
    /// \param counter_  - счетчик;
    /// \param maxcount_ - максимально допустимое значение счетчика;
    /// \param test_     - проверяемое условие.
    ///
    #define CASSERT_ID( group_, id_, counter_, maxcount_, test_ )     \
        do                                                            \
        {                                                             \
            if( !( test_ ) )                                          \
            {                                                         \
                if( ( ( counter_ ) += CASSERT_INC ) >= maxcount_ )    \
                {                                                     \
                    ERROR_ID( ( group_ ), ( id_ ) );                  \
                    ( counter_ ) = ( maxcount_ );                     \
                }                                                     \
            }                                                         \
            else                                                      \
            {                                                         \
                if( ( counter_ ) > 0 )                                \
                {                                                     \
                    if( ( counter_ ) >= CASSERT_DEC )                 \
                    {                                                 \
                        ( counter_ ) -= CASSERT_DEC;                  \
                    }                                                 \
                    else                                              \
                    {                                                 \
                        ( counter_ ) = 0;                             \
                    }                                                 \
                }                                                     \
            }                                                         \
        } while( 0 )
    
    //*****************************************************************************
    /// \brief Проверка утверждения со счетчиком.
    /// \details Макрос вызывает #CASSERT_ID c
    /// параметрами \a group_ и \a id_, равными #ASSERT_DEF_CODE.
    /// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения 
    /// не выполняется.
    /// \param counter_  - счетчик;
    /// \param maxcount_ - максимально допустимое значение счетчика;
    /// \param test_     - проверяемое условие.
    ///
    #define CASSERT( counter_, maxcount_, test_ ) \
            CASSERT_ID( ASSERT_DEF_CODE, ASSERT_DEF_CODE, counter_, maxcount_, test_ ) 

// Дополнительная проверка условий, которая отключается при помощи 
// директивы ENABLED_DEBUG_ASSERT.
// \note Используется при проведении тестирования и отладки
//
#ifdef ENABLED_DEBUG_ASSERT

    #warning "The project is compiled with the directive ENABLED_DEBUG_ASSERT"

    #define DERROR_ID( group_, id_ )   ERROR_ID( group_, id_ )
    
    #define DERROR( )                 ERROR( )
    
    #define DASSERT_ID( group_, id_, test_ )  ASSERT_ID( ( group_ ), ( id_ ), ( test_ ) )
    
    #define DASSERT( test_ )     ASSERT( ( test_ ) )
    
    #define DCASSERT_ID( group_, id_, counter_, maxcount_, test_ ) \
                CASSERT_ID( ( group_ ), ( id_ ), ( counter_ ), ( maxcount_ ), ( test_ ) )
    
    #define DCASSERT( counter_, maxcount_, test_) \
                CASSERT( ( counter_ ), ( maxcount_ ), ( test_ ) ) 
    
#else                               // ENABLED_DEBUG_ASSERT

    //*****************************************************************************
    // Глобальные константы, определенные через макросы
    //*****************************************************************************
    
    //*****************************************************************************
    /// \brief Дополнительное макроопределение: ошибка с использованием типа и 
    /// идентификатора исключения.
    /// \note Эквивалентно #ERROR_ID, отключается при помощи директивы
    /// \a ENABLED_DEBUG_ASSERT).
    ///
    #define DERROR_ID( group_, id_ )                               ( ( void )0 )
    
    //*****************************************************************************
    /// \brief Дополнительное макроопределение: ошибка.
    /// \note Эквивалентно #ERROR, отключается при помощи директивы
    /// \a ENABLED_DEBUG_ASSERT).
    ///
    #define DERROR( )                                               ( ( void )0 )
    
    //*****************************************************************************
    /// \brief Дополнительное макроопределение, проверяющее условие.
    /// \note Эквивалентно #ASSERT_ID, отключается при помощи директивы
    /// \a ENABLED_DEBUG_ASSERT).
    ///
    #define DASSERT_ID( group_, id_, test_ )                       ( ( void )0 )
    
    //*****************************************************************************
    /// \brief Дополнительное макроопределение, проверяющее условие.
    /// \note Эквивалентно #ASSERT, отключается при помощи директивы
    /// \a ENABLED_DEBUG_ASSERT).
    ///
    #define DASSERT( test_ )                                       ( ( void )0 )
    
    //*****************************************************************************
    /// \brief Дополнительное макроопределение 
    /// \note Аналогично #CASSERT_ID, отключается при помощи директивы
    /// \a ENABLED_DEBUG_ASSERT).
    ///
    #define DCASSERT_ID( group_, id_, counter_, maxcount_, test_ ) ( ( void )0 )
    
    //*****************************************************************************
    /// \brief Дополнительное макроопределение 
    /// \note Аналогично #CASSERT, отключается при помощи директивы
    /// \a ENABLED_DEBUG_ASSERT).
    ///
    #define DCASSERT( counter_, maxcount_, test_)                 ( ( void )0 )

#endif                                            // ENABLED_DEBUG_ASSERT == 1 #else

#endif                                            // DISABLED_ASSERT #else

#ifdef DEBUG_EXCEPTION // Вызов функции перехода в ЗС

    #warning "The project is compiled with the directive DEBUG_EXCEPTION"
    
    //*****************************************************************************
    // Определение глобальных переменных
    //*****************************************************************************
    
    //*****************************************************************************
    // Код отказа, который ожидается в системе. 
    // При уходе в отказ с таким кодом тест не fail-ится
    extern uint16_t exceptionExpectedErrorCode;
    
    //*****************************************************************************
    // Признак того, что отказ с ожидаемым кодом произошел. 
    // При срабатывании отказа с кодом, отличным от ожидаемого, 
    // флаг сбрасывается.
    extern BOOL exceptionErrorCodeIsExpected;

#endif

//*****************************************************************************
// Прототипы интерфейсных функций
//*****************************************************************************

//*****************************************************************************
/// \brief Обработка исключений.
/// \param file  – указатель на имя файла, в котором было обнаружено некорректное
/// поведение системы;
/// \param line  – номер строки, в которой было обнаружено некорректное 
/// поведение системы или тип и идентификатор исключения;
/// \param group – код ошибки;
/// \param id    – идентификатор ошибки.
/// \note Вызывается когда проверяемое утверждение неверно
/// и переводит прибор в ЗС.
/// \note Для выполнения модульного тестирования данная функция может 
/// быть переопределена.
///
void sysAssertException( char const *const file,
                         int16_t           line,
                         int16_t           group,
                         int16_t           id );

#endif

//*****************************************************************************
/**
* История изменений:
* 
* Версия 1.0.1
* Дата   09-02-2016
* Автор  Годунок А.Н.
* 
* Изменения:
*    Базовая версия.
* 
* Версия 1.0.2
* Дата   09-07-2018
* Автор  Годунок А.Н.
* 
* Изменения:
*     Добавлена возможность отключать передачу в функцию обработки исключений 
*     \a sysAssertException номера строки, на которой расположена проверка 
*     утверждения вызвавшая исключение.
*     Сама передача номера строки организована при помощи макроса 
*     \a LINE_NUMBER, который определяет передавать номер строки или вместо 
*     него передавать ноль. По умолчанию передается номер строки. Для того, 
*     чтобы вместо номера передавалось значение ноль, необходимо в свойствах 
*     проекта определить директиву \a DONT_SAVE_LINE_NUMBER. В этом случае, при 
*     компиляции будет выдаваться предупреждение «The project is compiled with the 
*     directive DONT_SAVE_LINE_NUMBER».
*     Отключить выдачу предупреждения «The project is compiled with 
*     the directive DONT_SAVE_LINE_NUMBER» можно определив в свойствах 
*     проекта директиву \a IGNORE_DONT_SAVE_LINE_NUMBER_WARNING.
*/

/**
* \file    asserts_ex.h
* \brief   Расширенные утверждения (assert).
* \details Расширенные утверждения - это аналоги утверждений модуля asserts.h, 
* которые используют модули BlackBox.h и Tracing.h компонента DebugTools.h.
* \details В случае, если проверяемое утверждение не выполняется, вызывается функция 
* #BlackBox_saveAddCodeProtectionState.
* \details Зависимости: 
* \details BlackBox\BlackBox.h
* \details DebugTools\Tracing.h
* \details Директива DISABLED_ASSERT отключает проверку утверждений.
* \details Директива DEBUG_EXCEPTION отключает вызов функции перехода в 
* защитный отказ и включает отладочную функцию.
*
* \version 1.0.2
* \date    09-07-2018
* \author  Годунок А.Н.
*/

//*****************************************************************************
// Команды препроцессора для предотвращения повторного включения содержимого файла
//*****************************************************************************
#ifndef ASSERTS_EX_H
#define ASSERTS_EX_H

//*****************************************************************************
// Подключаемые файлы
//*****************************************************************************
#include "asserts.h"
#include "BlackBox.h"

//*****************************************************************************
// Макроопределения, управляющие компиляцией
//*****************************************************************************

//*****************************************************************************
/* Если определено DISABLED_ASSERT - проверка исключений отключена, макросы пустые */
#ifdef DISABLED_ASSERT     

//*****************************************************************************
// Макросы типа функция
//*****************************************************************************

//*****************************************************************************
#define ERROR_EX_ID( group_, id_, p1_, p2_, p3_, p4_ )                ( ( void )0 )
#define ERROR_EX( p1_, p2_, p3_, p4_ )                                ( ( void )0 )
#define ERROR_EX2_ID( group_, id_, p1_, p2_ )                         ( ( void )0 )
#define ASSERT_EX_ID( group_, id_, test_, p1_, p2_, p3_, p4_ )        ( ( void )0 )
#define ASSERT_EX2( test_, p1_, p2_ )                                 ( ( void )0 )
#define ASSERT_EX( test_, p1_, p2_, p3_, p4_ )                        ( ( void )0 )
#define ASSERT_EX2_ID( group_, id_, test_, p1_, p2_ )                 ( ( void )0 )
#define CASSERT_EX_ID( group_, id_, counter_, maxcount_, test_,                \
                       p1_, p2_, p3_, p4_ )                        ( ( void )0 )
#define CASSERT_EX( counter_, maxcount_, test_,                                \
                    p1_, p2_, p3_, p4_ )                           ( ( void )0 )

#define DERROR_EX_ID( group_, id_, p1_, p2_, p3_, p4_ )               ( ( void )0 )
#define DERROR_EX( p1_, p2_, p3_, p4_ )                               ( ( void )0 )
#define DASSERT_EX_ID( group_, id_, test_, p1_, p2_, p3_, p4_ )       ( ( void )0 )
#define DASSERT_EX( test_, p1_, p2_, p3_, p4_ )                       ( ( void )0 )
#define DCASSERT_EX_ID( group_, id_, counter_, maxcount_, test_,               \
                        p1_, p2_, p3_, p4_ )                       ( ( void )0 )
#define DCASSERT_EX( counter_, maxcount_, test_,                               \
                     p1_, p2_, p3_, p4_ )                          ( ( void )0 )

#else  // Если ENABLED_ASSERT не определена проверка утверждений разрешена

//*****************************************************************************
// Макросы типа функция
//*****************************************************************************

//*****************************************************************************
/// \brief Расширенная ошибка с использованием типа и идентификатора
/// исключения.
/// \note Макрос проверяет вызов функции #sysAssertException.
/// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения 
/// не выполняется.
/// \note В функцию #sysAssertException в параметрах передаются имя файла, 
/// в котором проверялось утверждение и номер строки с неправильным 
/// утверждением.
/// \param group_ - тип отказа;
/// \param id_    - идентификатор отказа;
/// \param p1_    - параметр отказа 1;
/// \param p2_    - параметр отказа 2;
/// \param p3_    - параметр отказа 3;
/// \param p4_    - параметр отказа 4.
///
#ifndef DEBUG_EXCEPTION

#define ERROR_EX_ID( group_, id_, p1_, p2_, p3_, p4_ )                           \
    do{                                                                          \
        BlackBox_saveAddCodeProtectionState( ( uint16_t )( p1_ ),( uint8_t )0 ); \
        BlackBox_saveAddCodeProtectionState( ( uint16_t )( p2_ ),( uint8_t )1 ); \
        BlackBox_saveAddCodeProtectionState( ( uint16_t )( p3_ ),( uint8_t )2 ); \
        BlackBox_saveAddCodeProtectionState( ( uint16_t )( p4_ ),( uint8_t )3 ); \
        sysAssertException( __FILE__, LINE_NUMBER, ( group_ ), (id_ ) );         \
    } while( 0 )
#else 
#define ERROR_EX_ID( group_, id_, p1_, p2_, p3_, p4_ )                           \
    do                                                                           \
    {                                                                            \
        sysAssertException( __FILE__, LINE_NUMBER, ( group_ ), ( id_ ) );        \
    } while( 0 )
#endif

//*****************************************************************************
/// \brief Расширенная ошибка.
/// \note Макрос вызывает #ERROR_EX_ID c
/// параметрами \a group_ и \a id_, равными #ASSERT_DEF_CODE.
/// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения
/// не выполняется.
/// \param p1_ - параметр отказа 1;
/// \param p2_ - параметр отказа 2;
/// \param p3_ - параметр отказа 3;
/// \param p4_ - параметр отказа 4.
///
#define ERROR_EX( p1_, p2_, p3_, p4_ )                                          \
            ERROR_EX_ID( ASSERT_DEF_CODE, ASSERT_DEF_CODE, p1_, p2_, p3_, p4_ ) \

//*****************************************************************************
        /// \brief Ошибка с идентификацией отказа и сохранением 2 параметров.
        /// \param group_ - тип отказа;
        /// \param id_    - идентификатор отказа;
        /// \param p1_    - параметр отказа 1;
        /// \param p2_    - параметр отказа 2.
        ///
        #define ERROR_EX2_ID( group_, id_, p1_, p2_ ) do                             \
        {                                                                            \
            BlackBox_saveAddCodeProtectionState( ( uint16_t )( p1_ ),( uint8_t )0 ); \
            BlackBox_saveAddCodeProtectionState( ( uint16_t )( p2_ ),( uint8_t )1 ); \
            sysAssertException( __FILE__, LINE_NUMBER, ( group_ ), ( id_ ) );        \
        } while( 0 )
            


//*****************************************************************************
/// \brief Расширенная проверка утверждения с использованием типа
/// и идентификатора исключения.
/// \param group_ - тип отказа;
/// \param id_    - идентификатор отказа;
/// \param test_  - проверяемое условие;
/// \param p1_    - параметр отказа 1;
/// \param p2_    - параметр отказа 2;
/// \param p3_    - параметр отказа 3;
/// \param p4_    - параметр отказа 4.
/// \note Макрос проверяет, что условие \a test_ выполняется. Если аргумент
/// \a test имеет значение false, вызывается макрос #ERROR_ID.
/// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения
/// не выполняется.
///
#define ASSERT_EX_ID( group_, id_, test_, p1_, p2_, p3_, p4_ )         \
    do                                                                 \
    {                                                                  \
        if( !( test_ ) )                                               \
        {                                                              \
            ERROR_EX_ID( group_, id_, p1_, p2_, p3_, p4_ );            \
        }                                                              \
    } while( 0 )

  //*****************************************************************************
    /// \brief Проверка утверждения с идентификацией отказа и сохранением 2 параметров.
    /// \param group_ - тип отказа;
    /// \param id_    - идентификатор отказа;
    /// \param test_  - проверяемое условие;
    /// \param p1_    - параметр отказа 1;
    /// \param p2_    - параметр отказа 2.
    /// \note Макрос проверяет, что условие \a test выполняется. Если аргумент 
    /// \a test имеет значение false, вызывается макрос #ERROR_ID.
    /// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения 
    /// не выполняется.
    /// 
    #define ASSERT_EX2_ID( group_, id_, test_, p1_, p2_ )  do          \
    {                                                                  \
        if( !( test_ ) )                                               \
        {                                                              \
            ERROR_EX2_ID( group_, id_, p1_, p2_ );                     \
        }                                                              \
    } while( 0 )

//*****************************************************************************
    /// \brief Проверка утверждения с сохранением 2 параметров.
    /// \param test_  - проверяемое условие;
    /// \param p1_    - параметр отказа 1;
    /// \param p2_    - параметр отказа 2.
    /// \note Макрос вызывает #ASSERT_ID c
    /// параметрами \a group_ и \a id_ равными #ASSERT_DEF_CODE.
    /// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения
    /// не выполняется.
    /// 
    #define ASSERT_EX2( test_, p1_, p2_ )                                 \
         ASSERT_EX2_ID( ASSERT_DEF_CODE, ASSERT_DEF_CODE, test_,          \
                     p1_, p2_ ) 


//*****************************************************************************
/// \brief Расширенная проверка утверждения.
/// \note Макрос вызывает #ASSERT_ID c
/// параметрами \a group_ и \a id_, равными #ASSERT_DEF_CODE.
/// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения
/// не выполняется.
/// \param test_ - проверяемое условие;
/// \param p1_   - параметр отказа 1;
/// \param p2_   - параметр отказа 2;
/// \param p3_   - параметр отказа 3;
/// \param p4_   - параметр отказа 4.
///
#define ASSERT_EX( test_, p1_, p2_, p3_, p4_ )                             \
         ASSERT_EX_ID( ASSERT_DEF_CODE, ASSERT_DEF_CODE, test_,            \
                     p1_, p2_, p3_, p4_ ) 

//*****************************************************************************
/// \brief Расширенная проверка утверждения со счетчиком с использованием
/// типа и идентификатора исключения.
/// \note Макрос проверяет, что условие \a test_ выполняется.
/// \note Если аргумент 
/// \a test_ имеет значение false, счетчик \a counter_ увеличивается на
/// величину #CASSERT_INC. 
/// \note Если счетчик достиг или превысил значение
/// \a maxcount_, вызывается макрос #ERROR_ID.
/// \note Если аргумент \a test_ имеет значение true, счетчик \a counter_
/// уменьшается на величину #CASSERT_DEC до нуля.
/// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения 
/// не выполняется.
/// \note Инициализацию счетчика начальным значением должен 
/// выполнить пользователь.
/// \param group_    - тип отказа;
/// \param id_       - идентификатор отказа;
/// \param counter_  - счетчик;
/// \param maxcount_ - максимально допустимое значение счетчика;
/// \param test_     - проверяемое условие;
/// \param p1_       - параметр отказа 1;
/// \param p2_       - параметр отказа 2;
/// \param p3_       - параметр отказа 3;
/// \param p4_       - параметр отказа 4.
///
#define CASSERT_EX_ID( group_, id_, counter_, maxcount_, test_,    \
                           p1_, p2_, p3_, p4_ )                    \
    do                                                             \
    {                                                              \
        if( !( test_ ) )                                           \
        {                                                          \
            if( ( ( counter_ ) += CASSERT_INC ) >= maxcount_ )     \
            {                                                      \
                ERROR_EX_ID( group_, id_, p1_, p2_, p3_, p4_ );    \
                ( counter_ ) = ( maxcount_ );                      \
            }                                                      \
        }                                                          \
        else                                                       \
        {                                                          \
            if( ( counter_ ) > 0 )                                 \
            {                                                      \
                if( ( counter_ ) >= CASSERT_DEC )                  \
                {                                                  \
                    ( counter_ ) -= CASSERT_DEC;                   \
                }                                                  \
                else                                               \
                {                                                  \
                    ( counter_ ) = 0;                              \
                }                                                  \
            }                                                      \
        }                                                          \
    } while( 0 )

//*****************************************************************************
/// \brief Расширенная проверка утверждения со счетчиком.
/// \note Макрос вызывает #CASSERT_ID c
/// параметрами \a group_ и \a id_, равными #ASSERT_DEF_CODE.
/// \note Если определена директива \a DISABLED_ASSERT, проверка утверждения 
/// не выполняется.
/// \param counter_  - счетчик;
/// \param maxcount_ - максимально допустимое значение счетчика;
/// \param test_     - проверяемое условие;
/// \param p1_       - параметр отказа 1;
/// \param p2_       - параметр отказа 2;
/// \param p3_       - параметр отказа 3;
/// \param p4_       - параметр отказа 4.
///
#define CASSERT_EX( counter_, maxcount_, test_, p1_, p2_, p3_, p4_ )    \
            CASSERT_EX_ID( group_, id_, counter_, maxcount_, test_,     \
                           p1_, p2_, p3_, p4_ )

// Дополнительная проверка условий, которая отключается при помощи 
// директивы #ENABLED_DEBUG_ASSERT.
// \note Используется при проведении тестирования и отладки
//
#ifdef ENABLED_DEBUG_ASSERT

//*****************************************************************************
// Макросы типа функция
//*****************************************************************************

//*****************************************************************************
#define DERROR_EX_ID( group_, id_, p1_, p2_, p3_, p4_ )                   \
                ERROR_EX_ID( group_, id_, p1_, p2_, p3_, p4_ )            

//*****************************************************************************
#define DERROR_EX( p1_, p2_, p3_, p4_ ) ERROR_EX( p1_, p2_, p3_, p4_ )    
 
//***************************************************************************** 
#define DASSERT_EX_ID( group_, id_, test_, p1_, p2_, p3_, p4_ )           \
            ASSERT_EX_ID( group_, id_, test_, p1_, p2_, p3_, p4_ )        

//*****************************************************************************
#define DASSERT_EX( test_, p1_, p2_, p3_, p4_ )                           \
            ASSERT_EX( test_, p1_, p2_, p3_, p4_ )                        

//*****************************************************************************
#define DCASSERT_EX_ID( group_, id_, counter_, maxcount_, test_,          \
                                p1_, p2_, p3_, p4_ )                      \
            CASSERT_EX_ID( group_, id_, counter_, maxcount_, test_,       \
                           p1_, p2_, p3_, p4_ )                           

//*****************************************************************************
#define DCASSERT_EX( counter_, maxcount_, test_, p1_, p2_, p3_, p4_ )     \
         CASSERT_EX( counter_, maxcount_, test_, p1_, p2_, p3_, p4_ )

#else                               // ENABLED_DEBUG_ASSERT

//*****************************************************************************
/// \brief Дополнительное макроопределение: расширенная ошибка с использованием
/// типа и идентификатора исключения.
/// \note Эквивалентно #ERROR_EX_ID, отключается при помощи директивы
/// \a ENABLED_DEBUG_ASSERT).
///
#define DERROR_EX_ID( group_, id_, p1_, p2_, p3_, p4_ )         ( ( void )0 )

//*****************************************************************************
/// \brief Дополнительное макроопределение: расширенная ошибка.
/// \note Эквивалентно #ERROR_EX, отключается при помощи директивы
/// \a ENABLED_DEBUG_ASSERT).
///
#define DERROR_EX( p1_, p2_, p3_, p4_ )                         ( ( void )0 )

//*****************************************************************************
/// \brief Дополнительное макроопределение, проверяющее условие.
/// \note Эквивалентно #ASSERT_EX_ID, отключается при помощи директивы
/// \a ENABLED_DEBUG_ASSERT).
///
#define DASSERT_EX_ID( group_, id_, test_, p1_, p2_, p3_, p4_ ) ( ( void )0 )

//*****************************************************************************
/// \brief Дополнительное макроопределение, проверяющее условие.
/// \note Эквивалентно #ASSERT_EX, отключается при помощи директивы
/// \a ENABLED_DEBUG_ASSERT).
///
#define DASSERT_EX( test_, p1_, p2_, p3_, p4_ )                 ( ( void )0 )

//*****************************************************************************
/// \brief Дополнительное макроопределение.
/// \note Аналогично #CASSERT_EX_ID, отключается при помощи директивы
/// \a ENABLED_DEBUG_ASSERT).
///
#define DCASSERT_EX_ID( group_, id_, counter_, maxcount_, test_,              \
                        p1_, p2_, p3_, p4_ )                      ( ( void )0 )

//*****************************************************************************
/// \brief Дополнительное макроопределение.
/// \note Аналогично #CASSERT_EX, отключается при помощи директивы
/// \a ENABLED_DEBUG_ASSERT).
///
#define DCASSERT_EX( counter_, maxcount_, test_,                             \
                     p1_, p2_, p3_, p4_ )                        ( ( void )0 )

#endif                                 // ENABLED_DEBUG_ASSERT == 1 #else

#endif                                 // DISABLED_ASSERT #else

#endif                                                        

//*****************************************************************************
/**
* История изменений:
* 
* Версия 1.0.1
* Дата   13-04-2016
* Автор  Годунок А.Н.
* 
* Изменения:
*    Базовая версия.
* 
* Версия 1.0.2
* Дата   09-07-2018
* Автор  Годунок А.Н.
* 
* Изменения:
*     Добавлена возможность отключать передачу в функцию обработки исключений 
*     \a sysAssertException номера строки, на которой расположена проверка 
*     утверждения вызвавшая исключение.
*     Сама передача номера строки организована при помощи макроса 
*     \a LINE_NUMBER, который определяет передавать номер строки или вместо 
*     него передавать ноль. По умолчанию передается номер строки. Для того, 
*     чтобы вместо номера передавалось значение ноль, необходимо в свойствах 
*     проекта определить директиву \a DONT_SAVE_LINE_NUMBER. В этом случае, при 
*     компиляции будет выдаваться предупреждение «The project is compiled with the 
*     directive DONT_SAVE_LINE_NUMBER».
*     Отключить выдачу предупреждения «The project is compiled with 
*     the directive DONT_SAVE_LINE_NUMBER» можно определив в свойствах 
*     проекта директиву \a IGNORE_DONT_SAVE_LINE_NUMBER_WARNING.
*/

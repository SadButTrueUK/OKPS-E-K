/**
* \file    BinIn.c
* \brief   \copybrief BinIn.h
* 
* \version 1.0.1
* \date    05-10-2018
* \author  Агулов М.А.
*/

//*****************************************************************************
// Подключаемые файлы
//*****************************************************************************
#include <string.h>
#include "ConfigMK.h"
#include "BinIn.h"
#include "IOports.h"
#include "InterChannel.h"
#include "asserts_ex.h"
#include "Tracing.h"
#include "CheckCallFunctions.h"

//*****************************************************************************
// Объявление типов данных
//*****************************************************************************

//*****************************************************************************
// Локальные константы, определенные через макросы
//*****************************************************************************

//*****************************************************************************
#define STATES_NUM              7           ///< Число байт состояний сигналов.
#define USEFUL_BYTES_NUM        5           ///< Число байт для синхронизации (байты считанных данных).
#define DELAY_LINE_LEN          6           ///< Длина линии задержки.

//*****************************************************************************
/// \brief Порог обнаружителя ( #DETECTION_THRESHOLD должно быть <= #DELAY_LINE_LEN).
///
#define DETECTION_THRESHOLD     4

//*****************************************************************************
#define SAMPLES_PER_BYTE        2           ///< Количество выборок в байте (читается тетрадами).

#define BININ_CHECK_OFF         0xF0        ///< Контроль состояний, все оптроны выключены.
#define BININ_CHECK_C0_C1       0xDE        ///< Контрольное значение, каналы 0 и 1.
#define BININ_CHECK_C2_C3       0x7B        ///< Контрольное значение, каналы 2 и 3.

#define BININ_BI_T1              500        ///< Максимальное время неприхода 2-го параметра.
#define BININ_BI_T2              500        ///< Максимальное время несовпадения параметров.
#define BININ_BI_T3                0        ///< Максимальное время обновления параметра (не контролируется).

#define BININ_BIP_T1              50        ///< Максимальное время неприхода 2-го параметра.
#define BININ_BIP_T2             100        ///< Максимальное время несовпадения параметров.
#define BININ_BIP_T3               0        ///< Максимальное время обновления параметра (не контролируется).

//*****************************************************************************
// Макросы для работы с портами чтения дискретных сигналов
#define D0          _RC10                                   ///< Чтение состояния сигнала D0.
#define D1          _RB8                                    ///< Чтение состояния сигнала D1.
#define D2          _RB9                                    ///< Чтение состояния сигнала D2.
#define D3          _RC6                                    ///< Чтение состояния сигнала D3.
#define PIN_24V     _RA8                                    ///< Чтение состояния сигнала 24 В.
#define PIN_220V    _RB13                                   ///< Чтение состояния сигнала 220 В.

//*****************************************************************************
// Макросы типа функция
//*****************************************************************************

//*****************************************************************************
// Макросы работы с портами выдачи адреса и сигналов тестирования

//*****************************************************************************
/// \brief Управление портом сигнала A0.
///
#define A0( x )   ( x ) ? ( _LATA15 = 1 ) : ( _LATA15 = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала A1.
///
#define A1( x )   ( x ) ? ( _LATA14 = 1 ) : ( _LATA14 = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала A2.
///
#define A2( x )   ( x ) ? ( _LATG2  = 1 ) : ( _LATG2  = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала A3.
///
#define A3( x )   ( x ) ? ( _LATG3  = 1 ) : ( _LATG3  = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала A4.
///
#define A4( x )   ( x ) ? ( _LATA14 = 1 ) : ( _LATA14 = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала A5.
///
#define A5( x )   ( x ) ? ( _LATD8  = 1 ) : ( _LATD8  = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала A6.
///
#define A6( x )   ( x ) ? ( _LATD8  = 1 ) : ( _LATD8  = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала A7.
///
#define A7( x )   ( x ) ? ( _LATA15 = 1 ) : ( _LATA15 = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала A8.
///
#define A8( x )   ( x ) ? ( _LATG2  = 1 ) : ( _LATG2  = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала CHD0.
///
#define CHD0( x ) ( x ) ? ( _LATB6 = 1 )  : ( _LATB6  = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала CHD1.
///
#define CHD1( x ) ( x ) ? ( _LATB5 = 1 )  : ( _LATB5  = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала CHD2.
///
#define CHD2( x ) ( x ) ? ( _LATB6 = 1 )  : ( _LATB6  = 0 )

//*****************************************************************************
/// \brief Управление портом сигнала CHD3.
///
#define CHD3( x ) ( x ) ? ( _LATB5 = 1 )  : ( _LATB5  = 0 )

//*****************************************************************************
/// \brief Структура состояния модуля безопасного чтения дискретных сигналов BinIn.h.
///
struct
{
    uint8_t RawData[STATES_NUM * DELAY_LINE_LEN];        ///< Буфер накопления обнаружителя.
    uint8_t Data[USEFUL_BYTES_NUM];                     ///< Выходные данные обнаружителя.
    uint8_t prevData[USEFUL_BYTES_NUM];                 ///< Выходные данные обнаружителя.
    uint8_t Cnt[8];                                     ///< Число единиц в байте.
    uint8_t syncCnt;                                    ///< Счетчик номера байта, отправляемого на синхронизацию.
    uint8_t ErrCnt;                                     ///< Счетчик CASSERT.
    uint8_t idxFSM;                                     ///< Переменная состояния FSM.
    uint8_t idxQueue;                                   ///< Индекс в буфере накопления обнаружителя.
} bi;

//*****************************************************************************
/// \brief Структура состояния внешних сигналов.
/// \note Объединение сделано для удобства доступа к данным разным компонентам.
///
typedef struct 
{
    /// \brief Переменная для байтового доступа.
    ///
    union
    {
        uint8_t Data;                                   ///< Переменная для байтового доступа.
        
        /// \brief Структура для битового доступа к переменной Data.
        ///
        struct
        {
            uint8_t s24V    :1;                         ///< Состояние датчика контроля 24 В.
            uint8_t s220V   :1;                         ///< Состояние датчика контроля 220 В.
            uint8_t sRPV    :1;                         ///< Состояние реле РПВ.
        };
    } Val;  
} PinIn;

//*****************************************************************************
/// \brief Структура состояния считывателя состояния перемычек на кросс-плате.
///
struct
{
    PinIn   RawData[DELAY_LINE_LEN];                    ///< Буфер накопления обнаружителя.
    uint8_t Data;                                       ///< Выходные данные обнаружителя.
    
    /// \brief Предыдущие выходные данные обнаружителя, отправленные на синхронизацию.
    ///
    uint8_t oldData;
    uint8_t syncTmr;                                    ///< Таймер периода синхронизации.     
    uint8_t syncCnt;                                    ///< Счетчик номера байта, отправляемого на синхронизацию.
    uint8_t idxFSM;                                     ///< Переменная состояния FSM.
} bip;

//*****************************************************************************
// Объявление локальных типизированных констант
//*****************************************************************************

//*****************************************************************************
/// \brief Массив состояний выходных ключей установки адреса и контроля.
///
const uint8_t SYNC_TIME = 10;                           

//*****************************************************************************
/// \brief Период отправки данных на синхронизацию, мс.
///
const uint16_t BinInState[STATES_NUM * SAMPLES_PER_BYTE]=
{ 
    0b1111111111111110,         // *State0
    0b1111111111111101,         // *State1
    0b1111111111111011,         // *State2
    0b1111111111110111,         // *State3
    0b1111111111101111,         // *State4
    0b1111111111011111,         // *State5
    0b1111111110111111,         // *State6
    0b1111111101111111,         // *State7
    0b1111111011111111,         // *State8   (AR)
    0b1111111111111111,         // *State9   Test state: All address off
    0b1111101111111111,         // *State10  Test state: CHD0=0
    0b1111011111111111,         // *State11  Test state: CHD1=0
    0b1110111111111111,         // *State12  Test state: CHD2=0
    0b1101111111111111          // *State13  Test state: CHD3=0
};

//*****************************************************************************
// Прототипы локальных функций
//*****************************************************************************

//*****************************************************************************
/// \brief Функция обнаружителя М из N.
/// \param RawDataStartPtr  - указатель на начало массива выборки;
/// \param RawDataFinishPtr - указатель на конец массива выборки;
/// \param NumStates - число состояний;
/// \param cntPtr - указатель на счетчик данных.
///
void BitDecode_asm ( uint8_t *RawDataStartPtr, uint8_t *RawDataFinishPtr, uint16_t NumStates, uint8_t *cntPtr );

//*****************************************************************************
// Реализация интерфейсных функций
//*****************************************************************************

//*****************************************************************************
// Инициализация переменных компонента
void BinIn_ctor( void )
{
    // Инициализация портов контроллера
    if( ConfigMK_isMaster( ) )
    {
        INIC_PORT_OUT( A, 15, eIO_openDrainOff );        
        INIC_PORT_OUT( A, 14, eIO_openDrainOff );        
        INIC_PORT_OUT( G,  2, eIO_openDrainOff );        
        INIC_PORT_OUT( D,  8, eIO_openDrainOff );        
        INIC_PORT_OUT( B,  5, eIO_openDrainOff );
        INIC_PORT_OUT( B,  6, eIO_openDrainOff );
    }
    else
    {
        INIC_PORT_OUT( A, 15, eIO_openDrainOff );        
        INIC_PORT_OUT( A, 14, eIO_openDrainOff );        
        INIC_PORT_OUT( G,  3, eIO_openDrainOff );        
        INIC_PORT_OUT( D,  8, eIO_openDrainOff );        
        INIC_PORT_OUT( G,  2, eIO_openDrainOff );        
        INIC_PORT_OUT( B,  5, eIO_openDrainOff );
        INIC_PORT_OUT( B,  6, eIO_openDrainOff );
    }

    INIC_PORT_IN( C, 10, eIO_pullOff );                 // Порт D0
    INIC_PORT_IN( B,  8, eIO_pullOff );                 // Порт D1
    INIC_PORT_IN( B,  9, eIO_pullOff );                 // Порт D2
    INIC_PORT_IN( C,  6, eIO_pullOff );                 // Порт D3

    // Порт KPOW220 (RB13) - контроль напряжения источника питания 220 В с помощью дискретного датчика после моста.
    INIC_PORT_IN( B, 13, eIO_pullOff );
    
    // Порт KPOW24 (RA8) - контроль напряжения источника питания 24 В.
    INIC_PORT_IN( A, 8, eIO_pullOff );
    
    memset( &bi,  0, sizeof( bi ) );                    // Очистка переменных и буферов
    memset( &bip, 0, sizeof( bip ) );                   // Очистка переменных и буферов
    
    bi.RawData[4] = BININ_CHECK_OFF;
    bi.RawData[5] = BININ_CHECK_C0_C1;                
    bi.RawData[6] = BININ_CHECK_C2_C3;            

    BinInAddrSet_interrupt( );                                                  // Установка адресов в начальное состояние

    
    InterChannel_setParamSettings( eICId_BinIn,                                 // Идентификатор параметра синхронизации.
                                   eScriptSync,                                 // Сценарий синхронизации.
                                   eProcSyncEqual,                              // Процедура синхронизации данных.
                                   eProcCheckEqual,                             // Процедура контроля данных.
                                   0, 
                                   0,               
                                   BININ_BI_T1, BININ_BI_T2, BININ_BI_T3 );     // Временные параметры синхронизации
    
    InterChannel_setParamSettings( eICId_BinInPin,                              // Идентификатор параметра синхронизации.
                                   eScriptSync,                                 // Сценарий синхронизации.
                                   eProcSyncEqual,                              // Процедура синхронизации данных.
                                   eProcCheckEqual,                             // Процедура контроля данных.
                                   0, 
                                   0,               
                                   BININ_BIP_T1, BININ_BIP_T2, BININ_BIP_T3 );  // Временные параметры синхронизации
}

//*****************************************************************************
// Функция чтения данных. Работает в прерывании #15
void BinInDataRead_interrupt( void )
{
    // Чтение пинов в буфер обнаружителя
    ( bi.idxQueue & 0x01 ) ? ( bi.RawData[bi.idxQueue>>1] |= (uint8_t)( D3<<3 | D2<<2 | D1<<1 | D0<<0 ) << 4 ):
                             ( bi.RawData[bi.idxQueue>>1]  = (uint8_t)( D3<<3 | D2<<2 | D1<<1 | D0<<0 ) );
    
    // Управление и контроль счетчика индекса буфера обнаружителя
    bi.idxQueue >= ( STATES_NUM * SAMPLES_PER_BYTE * DELAY_LINE_LEN  - 1 ) ? ( bi.idxQueue = 0 ) : ( bi.idxQueue++ );
    
    // Инкремент и контроль счётчика автомата состояний
    bi.idxFSM < ( STATES_NUM * SAMPLES_PER_BYTE - 1 ) ? ( bi.idxFSM++ ) : ( bi.idxFSM = 0 );

    // Чтение дискретных сигналов с пинов
    bip.RawData[bip.idxFSM].Val.s24V  = PIN_24V;
    bip.RawData[bip.idxFSM].Val.s220V = PIN_220V;
    bip.RawData[bip.idxFSM].Val.sRPV  = bi.Data[4] & 0x01;
}

//*****************************************************************************
//Чтение тетрады данных. Функция работает в прерывании #0.
//Функция выполняет чтение тетрады данных с портов контроллера и упаковывает их в байты. 
//Упакованные данные помещаются в массив накопления RawData, который обрабатывается в основном цикле
void BinInAddrSet_interrupt( void )
{
    if( ConfigMK_isMaster( ) )
    {
        A0( BinInState[bi.idxFSM]   & ( 1<<0 )  );
        A1( BinInState[bi.idxFSM]   & ( 1<<1 )  );    
        A2( BinInState[bi.idxFSM]   & ( 1<<2 )  );
        A5( BinInState[bi.idxFSM]   & ( 1<<5 )  );
        CHD2( BinInState[bi.idxFSM] & ( 1<<12 ) );
        CHD3( BinInState[bi.idxFSM] & ( 1<<13 ) );
    } 
    else
    {
        A3( BinInState[bi.idxFSM]   & ( 1<<3 )  );
        A4( BinInState[bi.idxFSM]   & ( 1<<4 )  );    
        A6( BinInState[bi.idxFSM]   & ( 1<<6 )  );
        A7( BinInState[bi.idxFSM]   & ( 1<<7 )  );            
        A8( BinInState[bi.idxFSM]   & ( 1<<8 )  );                
        CHD0( BinInState[bi.idxFSM] & ( 1<<10 ) );
        CHD1( BinInState[bi.idxFSM] & ( 1<<11 ) );
    }
}

//*****************************************************************************
// Обработка входных сигналов, считанных в прерываниях функцией BinInDataRead_interrupt
void BinIn_run( void )
{
    // Обработка данных с дешифратора
    // Декодирование только в нечётных прерываниях, только информационные байты
    if( ( bi.idxFSM & 0x01 ) && ( bi.idxFSM >> 1 < USEFUL_BYTES_NUM ) )
    {
        BitDecode_asm( &bi.RawData[bi.idxFSM >> 1], &bi.RawData[STATES_NUM * DELAY_LINE_LEN - 1], 
            STATES_NUM, &bi.Cnt[sizeof( bi.Cnt ) - 1] );                        // Число обнаруженных лог. 1

        // Сравнение результата обнаружения с порогами обнаружителя
        for( uint8_t i = 0; i < 8; i++ )
        {
            if( bi.Cnt[i] >= DETECTION_THRESHOLD )
                bi.Data[bi.idxFSM >> 1] |= 1 << i;                              // Обнаружено превышение порога  лог. 1

            if( ( DELAY_LINE_LEN - bi.Cnt[i] ) >= DETECTION_THRESHOLD )
                bi.Data[bi.idxFSM >> 1] &= ~( 1 << i );                         // Обнаружено превышение порога  лог. 0
        }
    }

    BitDecode_asm( (uint8_t*)&bip.RawData, (uint8_t*)&bip.RawData[DELAY_LINE_LEN - 1], 
                   1, &bi.Cnt[sizeof( bi.Cnt ) - 1] );                          // Число обнаруженных лог. 1

    // Сравнение результата обнаружения с порогами обнаружителя
    for( uint8_t i = 0; i < 8; i++ )
    {
        if( bi.Cnt[i] >= DETECTION_THRESHOLD )
            bip.Data |= 1 << i;                                                 // Обнаружено превышение порога  лог. 1

        if( ( DELAY_LINE_LEN - bi.Cnt[i] ) >= DETECTION_THRESHOLD )
            bip.Data &= ~( 1 << i );                                            // Обнаружено превышение порога  лог. 0
    }

    bip.idxFSM >= ( DELAY_LINE_LEN - 1 ) ? ( bip.idxFSM = 0 ):( bip.idxFSM++ );

    
// Синхронизация данных bip.Data с периодом SYNC_TIME
    if (++bip.syncTmr == SYNC_TIME)
    {
        InterChannel_synchronize(eICId_BinInPin, bip.Data);
        bip.syncTmr = 0;
    }   

    
    // Синхронизация данных bi.Data и контроль оптронов
    if( !bi.idxQueue )
    {   
    // Проверка тестовых воздействий происходит при каждом обновлении всего буфера накопителя. 
    // Время между проверками вычисляется по формуле: DELAY_LINE_LEN * STATES_NUM * SAMPLES_PER_BYTE = 84 мс. 
        CASSERT_EX_ID( eGrPS_BinIn, ePS_BinInErrorTestDecoder,
                       bi.ErrCnt,
                       6,
                       ( bi.RawData[4] & 0xF0 ) == BININ_CHECK_OFF           // Проверка тестового воздействия
                       && bi.RawData[5]         == BININ_CHECK_C0_C1         // Проверка тестового воздействия
                       && bi.RawData[6]         == BININ_CHECK_C2_C3,        // Проверка тестового воздействия
                       0, 0, 0, 0 );            

    // Синхронизация происходит при обновлении всего буфера накопителя. 
    // Интервал синхронизации вычисляется по формуле: DELAY_LINE_LEN * STATES_NUM * SAMPLES_PER_BYTE = 84 мс.
        if( !InterChannel_isHandling( eICId_BinIn ) )
            InterChannel_synchronize( eICId_BinIn, ( ~bi.Data[bi.syncCnt] & 0x00FF ) | bi.syncCnt << 8 );

        bi.syncCnt == ( USEFUL_BYTES_NUM - 1 ) ? ( bi.syncCnt = 0 ) : ( bi.syncCnt++ ) ;
    }
    MARKED_CALL_FUNCTION;
}

//*****************************************************************************
// Возвращает состояние перемычек адреса прибора
uint16_t BinIn_getAddrJumpers( void )
{
    return ~( (uint16_t)( bi.Data[1] << 8 ) | (uint16_t)bi.Data[0] );
}

//*****************************************************************************
// Возвращает состояние перемычек контрольной суммы (CRC)
uint8_t BinIn_getCrcJumpers( void )
{
    return ~bi.Data[3];
}

//*****************************************************************************
// Возвращает состояние перемычек конфигурации
uint8_t BinIn_getConfigJumpers( void )
{
    return ~bi.Data[2];  
}

//*****************************************************************************
// Возвращает состояние контактов реле РПВ 
bool BinIn_isRpvOnMe( void )
{
    PinIn temp;
    
        temp.Val.Data = InterChannel_getData( eICId_BinInPin );
        return !temp.Val.sRPV;    
}

//*****************************************************************************
//Возвращает синхронизированный результат контроля напряжения источника питания 220 В
//true  - норма;
//false - авария
bool BinIn_is220vOk( void )
{
    PinIn temp;
    
        temp.Val.Data = InterChannel_getData( eICId_BinInPin );
        return !temp.Val.s220V;
}

//*****************************************************************************
//Возвращает синхронизированный результат контроля напряжения источника питания 24 В.
//true  - норма;
//false - авария.
bool BinIn_is24vOk( void )
{
PinIn temp;

    temp.Val.Data = InterChannel_getData( eICId_BinInPin );
    return !temp.Val.s24V;
}

//*****************************************************************************
/**
* История изменений: 
* 
* Версия 1.0.1
* Дата   05-10-2018
* Автор  Агулов М.А.
* 
* Изменения:
*     Базовая версия.
*/

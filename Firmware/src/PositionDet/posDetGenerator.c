/**
* \file    posDetGenerator.c
* \brief   \copybrief posDetGenerator.h
*
* \version 1.0.5
* \date    13-01-2020
* \author  Кругликов В.П.
*/

//*****************************************************************************
// Подключаемые файлы
//*****************************************************************************
#include "posDetGenerator.h"
#include "asserts_ex.h"
#include "ProtectionState_codes.h"
#include "posDetGen_drv.h"
#include "typeMK.h"
#include "OverloadDet.h"
#include "AnalogMeasurement.h"
#include "CheckSupply.h"
#include "ActivityManager.h"
#include "Main.h"
#include "Interchannel.h"

//*****************************************************************************
// Локальные константы, определенные через макросы
//*****************************************************************************

//*****************************************************************************
/// \brief Значение регистра PTPER для 28 кГц ШИМ генератора.
///
#define PWM_PERIOD_POS_DET_GEN            4208U

//*****************************************************************************
/// \brief Середина таблицы сигнала контрольного генератора.
///
#define MIDDLE_UGEN_VALUE     PWM_PERIOD_POS_DET_GEN / 2

//*****************************************************************************
/// \brief Количество точек в таблице синусоиды на период (является результатом вычисления выражения
/// Fsi/Fsin, где Fsi - частота системного прерывания 16000 Гц, Fsin - частота синусоиды 62.5 Гц). 
///
#define SIN_POINTS_NUM        256U

//*****************************************************************************
// Объявление типов данных
//*****************************************************************************

//*****************************************************************************
/// \brief Структура состояния.
///
typedef struct
{
    uint8_t ctrl                    :1;    ///< Включение модуля.
    uint8_t interruptCtrl           :1;    ///< Разрешение прерываний.
    uint8_t controlGenIsFail        :1;    ///< Признак нерабочего состояния контрольного генератора
    uint8_t isActualGenData         :1;    ///< Признак того, что полученные данные можно обрабатывать
    uint8_t isChangeLevelInProcess  :1;    ///< Признак того, что идёт переходной процесс после смены уровня напряжения 
    uint8_t unused                  :3;    ///< Неиспользуемые биты.
} PosDetGener_flags;

//*****************************************************************************
/// \brief Объединение флагов состояния с \a uint8_t.
///
typedef union
{
    PosDetGener_flags str;         ///< Флаги состояния.
    uint8_t           data;        ///< Данные флага состояния.
} uPosDetGener_flags;

//*****************************************************************************
/// \brief Идентификаторы состояния функции #PosDetGenerator_run.
///
typedef enum PosDetGenerStates_
{
    eInit,
    eSwitchedOff,               ///< выключен
    eSwitchedOn,                ///< включен
} PosDetGenerStates;

//*****************************************************************************
// Объявление локальных типизированных констант
//*****************************************************************************

//*****************************************************************************
/// \brief Значения таблицы сигнала генератора контрольного напряжения.
///
const int16_t posDetGener_sinTable[SIN_POINTS_NUM] =
{
    0, 50 , 100 , 150 , 200 , 250 , 299 , 349 , 398 , 447 , 496 , 544 , 592 , 640 , 688 , 735 , 781 , 827 , 873 , 918 ,
    962 , 1006 , 1049 , 1092 , 1134 , 1175 , 1216 , 1256 , 1295 , 1333 , 1371 , 1407 , 1443 , 1478 , 1512, 1545 ,1578 ,
    1609 , 1639 , 1669 , 1697 , 1724 , 1751 , 1776 , 1800 , 1823 , 1845 , 1866 , 1886 , 1904 , 1922 , 1938, 1953, 1967,
    1980 , 1991 , 2002 , 2011 , 2019 , 2026 , 2031 , 2035 , 2038 , 2040 , 2041 , 2040 , 2038 , 2035, 2031, 2026 , 2019,
    2011 , 2002 , 1991 , 1980 , 1967 , 1953 , 1938 , 1922 , 1904 , 1886 , 1866 , 1845 , 1823, 1800, 1776,  1751 , 1724,
    1697 , 1669 , 1639 , 1609 , 1578 , 1545 , 1512 , 1478 , 1443 , 1407 , 1371 , 1333 , 1295 , 1256, 1216, 1175,  1134,
    1092 , 1049 , 1006 , 962 , 918 , 873 , 827 , 781 , 735 , 688 , 640 , 592 , 544 , 496 , 447 , 398 , 349 , 299 , 250,
    200 , 150 , 100 , 50 , 0 , -50 , -100 , -150 , -200 , -250 , -299 , -349 , -398 , -447 , -496 , -544 , -592 , -640,
    -688 , -735 , -781 , -827 , -873 , -918 , -962 , -1006 , -1049 , -1092, -1134, -1175, -1216, -1256, -1295 , -1333 ,
    -1371 , -1407 , -1443 , -1478 , -1512 , -1545 , -1578 , -1609, -1639, -1669, -1697, -1724 , -1751 , -1776 , -1800 ,
    -1823 , -1845 , -1866 , -1886 , -1904 , -1922 , -1938 , -1953 , -1967 , -1980 , -1991, -2002, -2011, -2019 , -2026,
    -2031 , -2035 , -2038 , -2040 , -2041 , -2040 , -2038 , -2035 , -2031 , -2026 , -2019, -2011 , -2002, -1991, -1980,
    -1967 , -1953 , -1938 , -1922 , -1904 , -1886 , -1866 , -1845 , -1823 , -1800 , -1776, -1751, -1724, -1697 , -1669,
    -1639 , -1609 , -1578 , -1545 , -1512 , -1478 , -1443 , -1407 , -1371 , -1333 , -1295, -1256, -1216, -1175 , -1134,
    -1092 , -1049 , -1006 , -962 , -918 , -873 , -827 , -781 , -735 , -688 , -640 , -592 , -544 , -496 , -447 ,  -398 ,
    -349 , -299 , -250 , -200 , -150 , -100 , -50
};

//*****************************************************************************
/// \brief Значения масштабирующего коэффициента для каждого уровня формируемого напряжения
///
static const uint16_t posDetGener_Ratio[] =
{
    7240, 7585, 7930, 8275, 8620, 8965, 9310, 9655, 10000
};

//*****************************************************************************
/// \brief Значения минимально допустимого напряжения обратной связи генератора (-10 % от номинального)
///
static const uint16_t posDetGener_MinThrUgen[] =
{
    665, 696, 728, 760, 791, 823, 855, 886, 918
};

//*****************************************************************************
/// \brief Значения максимально допустимого напряжения обратной связи генератора (+10 % от номинального)
///
static const uint16_t posDetGener_MaxThrUgen[] =
{
    812, 851, 890, 928, 967, 1006, 1045, 1083, 1122
};

//*****************************************************************************
/// \brief Значение максимально допустимого безопасного напряжения обратной связи генератора, соответствующее 33.25В.
/// Согласно ТЗ напряжение 33.25В является максимально безопасным, выше которого прибор уходит в защитный отказ 
static const uint16_t MAX_SAFE_VALUE_UGEN_FB  = 1200;

static const uint8_t MIN_LEVEL_UGEN = 1;              ///< Минимальный уровень формируемого напряжения
static const uint8_t MAX_LEVEL_UGEN = 9;              ///< Максимальный уровень формируемого напряжения 
static const uint8_t MAX_VAL_UGEN_IN_ORDER = 15;      ///< Максимальное число уровня, передаваемое в приказе от УС     

//*****************************************************************************
static const uint16_t SCALE_UGEN_VALUE = 10000;        ///< Размах шкалы для формирования напряжения генератора
static const uint8_t DEFAULT_LEVEL_UGEN = 7;           ///< Значение напряжения, формируемое по умолчанию 

//*****************************************************************************
// Объявление локальных переменных
//*****************************************************************************

//*****************************************************************************
static                   uPosDetGener_flags flags;        ///< Флаги состояния.
static PosDetGenerStates stepCnt;                         ///< Счетчик автомата состояния модуля.
static volatile uint16_t sinCnt  = 0;                     ///< Счетчик значений ШИМ.
static uint8_t           levelUgenCurrent;                ///< Уровень устанавливаемого напряжения КЦ(текущий).
static uint8_t           levelUgenPrevious;               ///< Уровень устанавливаемого напряжения КЦ (предыдущий).
static uint16_t          t_o_cnt;                         ///< Счетчик тайм-аута

//*****************************************************************************
// Прототипы локальных функций
//*****************************************************************************

//*****************************************************************************
/// \brief Проверка актуальных для обработки данных генератора контрольных цепей .
/// \details Данные считаются актуальными только тогда, когда истёк тайм-аут DEVICE_HAVE_NOT_ACTUAL_DATA в одном из следующих случаев:
/// 1. После включения генератора;
/// 2. При изменении уровня напряжения в приказе от управляющей системы.
/// Также данные могут обрабатываться, когда окончен тайм-аут по включению питания STARTUP_TIMEOUT
///
static void checkGeneratorData( void );

//*****************************************************************************
// Реализация локальных функций
//*****************************************************************************

//*****************************************************************************
//Проверка актуальных для обработки данных генератора контрольных цепей 
static void checkGeneratorData( void )
{
    static uint16_t timeout;
    static const uint16_t DEVICE_HAVE_NOT_ACTUAL_DATA = 300;
    enum intStates_t
    {
        eOff,
        eOn,
        eReadyToUse
    };
    static enum intStates_t states = eOff;
    
    if( ActivityManager_isActive( activityManager ) == false )
    {
        states = eOff; 
        flags.str.isActualGenData = 0;
        flags.str.isChangeLevelInProcess = 0; 
        return;
    }
    switch( states )
    {
        case eOff:
            if( flags.str.isChangeLevelInProcess || stepCnt == eSwitchedOn )
            {
                timeout = DEVICE_HAVE_NOT_ACTUAL_DATA;
                states = eOn;
            }
            break;
        case eOn:
            if( --timeout == 0 )
            {
                flags.str.isActualGenData = 1;
                states = eReadyToUse; 
                flags.str.isChangeLevelInProcess = 0;     
            }
            break;
        case eReadyToUse:
            break;
    }    
}

//*****************************************************************************
// Реализация интерфейсных функций
//*****************************************************************************

uint8_t PosDetGenerator_isReadyForUse( void )
{
    return flags.str.isActualGenData;
}

//*****************************************************************************
// Инициализация
void PosDetGenerator_ctor( void )
{
    static const uint16_t STARTUP_TIMEOUT = 3100;
    
    PosDetGenDrv_init( );
    //Отключение ШИМ, назначение выводов как IO Ports
    PosDetGenDrv_setDisable( );
    flags.data = 0;
    sinCnt = 0;
    stepCnt = eInit;
    levelUgenCurrent = levelUgenPrevious = DEFAULT_LEVEL_UGEN;
    t_o_cnt = STARTUP_TIMEOUT;
}

//*****************************************************************************
//Получить значение уровня генератора КЦ
uint8_t PosDetGenerator_getLevel ( void )
{
    return levelUgenCurrent + 1;
}

//*****************************************************************************
//Установить уровень напряжения генератора КЦ
void PosDetGenerator_setLevel ( uint8_t val ) 
{
    if( val ) //если передан 0, то устанавливаемое напряжение не изменяется
    {
        if( ( val >= MIN_LEVEL_UGEN ) && ( val <= MAX_LEVEL_UGEN ) )
            levelUgenCurrent = val - 1; 
        else  if( ( val > MAX_LEVEL_UGEN ) && ( val <= MAX_VAL_UGEN_IN_ORDER ) )
            levelUgenCurrent = MAX_LEVEL_UGEN - 1;
    
        //при изменении величины уровня в приказе перезаписать значение и уйти на установку тайм-аута ожидания готовности данных 
        if( levelUgenCurrent != levelUgenPrevious )
        {
            levelUgenPrevious = levelUgenCurrent;
            flags.str.isChangeLevelInProcess = 1;
        }
    }
}

//*****************************************************************************
// Управление работой
void PosDetGenerator_run( void )
{
            
    if( t_o_cnt ) 
        t_o_cnt--;  
    
    checkGeneratorData(  );         //Проверка готовности актуальных данных генератора
    
    switch( stepCnt )
    {
        case eInit:                 //Инициализация по включению питания
            if( t_o_cnt == 0 )
                stepCnt = eSwitchedOff; 
            break;
        case eSwitchedOff:          //Отключен, ожидание включения
            if( flags.str.ctrl && CheckSupply_is24vOn( ) )
            {   //Включение
                //Включение ШИМ, установка периода и начального значения
                PosDetGenDrv_setEnable( PWM_PERIOD_POS_DET_GEN, MIDDLE_UGEN_VALUE +  
                __builtin_divsd( __builtin_mulsu( posDetGener_sinTable[sinCnt], posDetGener_Ratio[levelUgenCurrent] ), SCALE_UGEN_VALUE ) );
                flags.str.interruptCtrl = 1; //Запуск
                stepCnt = eSwitchedOn;
            }
            break;

        case eSwitchedOn:           //Включен, ожидание отключения
            if( flags.str.ctrl == 0 || CheckSupply_is24vOn( ) == false )
            {   //Выключение
                //Переход на останов генератора 
                flags.str.interruptCtrl = false; //Останов
                PosDetGenDrv_setDisable( );
                stepCnt = eSwitchedOff;
            }
            break;

        default:                    //Неизвестное состояние автомата
            ERROR_ID( eGrPS_PositionDet, ePS_PosDetGenStepCntError );
    }
}

//*****************************************************************************
// Прерывание (обновление ШИМа)
void PosDetGenerator_interrupt( void )
{
    if( flags.str.interruptCtrl || sinCnt )
    {     //Не отключен 
        if( PosDetGenDrv_setValue( MIDDLE_UGEN_VALUE + __builtin_divsd( __builtin_mulsu( posDetGener_sinTable[sinCnt],  
            posDetGener_Ratio[levelUgenCurrent] ), SCALE_UGEN_VALUE ) ) )
        { //Записано новое значение ШИМ
            if( ++sinCnt == SIN_POINTS_NUM ) 
                sinCnt = 0;
        }
    }
}

//*****************************************************************************
// Включение/выключение
void PosDetGenerator_turnOn( bool state )
{
    flags.str.ctrl = state;
}

//*****************************************************************************
// Проверка состояния
bool PosDetGenerator_isEnable( void )
{
    return stepCnt != eSwitchedOff && stepCnt != eInit;
}

//*****************************************************************************
//Контроль напряжения обратной связи генератора контрольного напряжения.
void PosDetGenerator_checkUfb( void )   
{
    uint16_t temp = AnalogMeasurement_getData( eAinchGEN )->rms;
    // проверяем при отсутствии КЗ контрольного генератора, работающем контрольном генераторе и присутствии 24 В
    if( OverloadDet_isScContrGen( ) == false &&
        flags.str.isActualGenData &&  
        flags.str.isChangeLevelInProcess == 0 && 
        CheckSupply_is24vOn( ) )
    {
        if ( temp > MAX_SAFE_VALUE_UGEN_FB )
            ERROR_EX_ID( eGrPS_PositionDet, ePS_PosDetGenFeedBackContrGen, temp, InterChannel_getData( eICId_U_R1rms ), 
                         InterChannel_getData( eICId_U_R2rms ), 0 );
        // проверка того, что напряжение обратной связи выходит за пределы
        flags.str.controlGenIsFail = temp < posDetGener_MinThrUgen[levelUgenCurrent] || 
                                     temp > posDetGener_MaxThrUgen[levelUgenCurrent];
    }
    else
        flags.str.controlGenIsFail = 0;
}

//*****************************************************************************
//Функция возвращает состояние генератора контрольного напряжения.
uint8_t PosDetGenerator_isGeneratorFail( void ) 
{
    return flags.str.controlGenIsFail;
}

//*****************************************************************************
/**
* История изменений: 
* 
* Версия 1.0.1
* Дата   28-12-2017
* Автор  Кругликов В.П.
* 
* Изменения:
*     Базовая версия.
* 
* Версия 1.0.2
* Дата   22-08-2018
* Автор  Кругликов В.П.
* 
* Изменения:
*     изменения в таблице синуса при переносе проекта на dsPIC33;
*     добавлена функция проверки напряжения обратной связи контрольного генератора PosDetGenerator_checkUfb;
*     при подготовке рабочей версии напряжения обратной связи контрольного генератора трассировку необходимо убрать.
*
* Версия 1.0.3
* Дата   6-11-2019
* Автор  Кругликов В.П.
*
* Изменения:
*     1. Изменена таблица синуса с учётом того, что сигнал нужно масштабировать (для регулировки уровня)
*     2. Изменения в функциях контроля сигнала генератора и функции формирования
*     3. Добавлены новые интерфейсы PosDetGenerator_setLevel для установки уровня, задаваемого в приказе от УС
*     и PosDetGenerator_getLevel для получения установленного уровня
*
* Версия 1.0.4
* Дата   12-12-2019
* Автор  Кругликов В.П.
*
* Изменения:
*    Добавлены функции 
*    checkGeneratorData, в которой делается проверка вышел ли генератор напряжения на рабочий режим
*    и интерфейс PosDetGenerator_isReadyForUse для других модулей, читающих данные этого модуля
*
* Версия 1.0.5
* Дата   13-01-2020
* Автор  Кругликов В.П.
*
* Изменения:
*    Изменена функция PosDetGenerator_checkUfb в соответствии с дополнением 2 (ред.3) к ТЗ   
*    Исправлены ошибки в функции checkGeneratorData. Удалён лишний код в функции PosDetGenerator_run (лишнее состояние автомата) 
*    В функции PosDetGenerator_run добавлено состояние eInit (по включению питания прибора)  
*/

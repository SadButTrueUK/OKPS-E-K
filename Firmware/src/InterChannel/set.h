/**
* \file    set.h
* \brief   Очередь с приоритетом, состоящая из 8 или 64 элементов
* \details Очередь с приоритетами позволяет добавлять в нее 
* элементы в произвольном порядке и извлекать их в порядке 
* их приоритетов.
* \details Добавление, извлечение и поиск элементов в очереди 
* осуществляется табличным способом.
*
* \version 1.0.2
* \date    14-05-2019
* \author  Годунок А.Н.
*/

//*****************************************************************************
// Команды препроцессора для предотвращения повторного включения содержимого файла
//*****************************************************************************
#ifndef SET_H
#define SET_H

//*****************************************************************************
// Макроопределения, управляющие компиляцией
//*****************************************************************************

//*****************************************************************************
// Расчет логарифма по основанию 2
#ifndef LOG2

    //*****************************************************************************
    // Макросы типа функция
    //*****************************************************************************
    
    //*****************************************************************************
    /// \brief Макрос возвращает \f$\log_2\left(n\_+1\right)\f$, где \a n_ = 0..255.
    /// \details Макрос возвращает номер наиболее значащего бита.
    /// \details Если макрос не определен ранее, будет использоваться таблица поиска.
    /// \param n_ – идентификатор элемента очереди.
    ///
    #define LOG2( n_ ) ( Log2_log2Lkup[( n_ )] )
    
    //*****************************************************************************
    // Таблица поиска для ( log2( n ) + 1 ), где #n - индекс этой таблицы.
    extern uint8_t const Log2_log2Lkup[256];

#endif            

//*****************************************************************************
// Объявление глобальных типизированных констант
//*****************************************************************************

//*****************************************************************************
// Таблица поиска для ( 1 << ( ( n - 1 ) % 8 ) ), где #n - индекс в таблицу.
extern uint8_t const Pwr2_pwr2Lkup[65];

//*****************************************************************************
// Таблица поиска для ~( 1 << ( ( n - 1 ) % 8 ) ), где #n - индекс в таблицу.
extern uint8_t const Pwr2_invPwr2Lkup[65];

//*****************************************************************************
// Таблица поиска для ( n - 1 ) / 8.
extern uint8_t const Pwr2_div8Lkup[65];

//*****************************************************************************
// Макросы типа функция
//*****************************************************************************

//*****************************************************************************
/// \brief Макрос определяется как true если приоритетная очередь \a me_ пуста.
/// \param me_ - объект очередь типа Set8_t.
///
#define Set8_isEmpty( me_ )   ( ( me_ )->bits == ( uint8_t ) 0 )    

//*****************************************************************************
/// \brief Макрос определяется как true если приоритетная очередь \a me_ не пуста.
/// \param me_ - объект очередь типа Set8_t.
///
#define Set8_notEmpty( me_ )  ( ( me_ )->bits != ( uint8_t ) 0 )  

//*****************************************************************************
/// \brief Макрос определяется как true если приоритетная очередь \a me_ не пуста.
/// \param me_ - объект очередь типа Set64_t.
///
#define Set64_notEmpty( me_ ) ( Set8_notEmpty( &( me_ )->super ) )        

//*****************************************************************************
/// \brief Макрос определяется как true если приоритетная очередь \a me_ содержит 
/// элемент \a n_.
/// \param me_ - объект очередь типа Set8_t;
/// \param n_ – идентификатор элемента очереди.
///
#define Set8_hasElement( me_, n_ )                      \
    ( ( ( me_ )->bits &Pwr2_pwr2Lkup[( n_ )] ) != 0 )

//*****************************************************************************
/// \brief Вставить элемент \a n_ в приоритетную очередь \a me_, \a n_ = 1..8.
/// \param me_ - объект очередь типа Set8_t;
/// \param n_ – идентификатор элемента очереди.
///
#define Set8_insert( me_, n_ )                   \
    ( ( me_ )->bits |= Pwr2_pwr2Lkup[( n_ )] )

//*****************************************************************************
/// \brief Удалить элемент \a n_ в приоритетной очереди \a me_, \a n_ = 1..8.
/// \param me_ - объект очередь типа Set8_t;
/// \param n_ – идентификатор элемента очереди.
///
#define Set8_remove( me_, n_ )                      \
    ( ( me_ )->bits &= Pwr2_invPwr2Lkup[( n_ )] )

//*****************************************************************************
/// \brief Найти элемент с наивысшим приоритетом в очереди \a me_ и 
/// сохранить его значение в \a n_.
/// \param me_ - объект очередь типа Set8_t;
/// \param n_ – идентификатор элемента очереди.
/// \note Если очередь \a me_ пуста, в \a n_ будет записан ноль.
///
#define Set8_findMax(me_, n_) ((n_) = LOG2((me_)->bits)) 

//*****************************************************************************
/// \brief Макрос определяется как true если приоритетная очередь \a me_ содержит 
/// элемент \a n_.
/// \param me_ - объект очередь типа Set64_t;
/// \param n_ – идентификатор элемента очереди.
///
#define Set64_hasElement( me_, n_ )                                          \
    ( Set8_hasElement( &( me_ )->subset[Pwr2_div8Lkup[( n_ )]], ( n_ ) ) )

//*****************************************************************************
/// \brief Вставить элемент \a n_ в приоритетную очередь \a me_, \a n_ = 1..64.
/// \param me_ - объект очередь типа Set64_t;
/// \param n_ – идентификатор элемента очереди.
///
#define Set64_insert( me_, n_ )                                              \
    do                                                                       \
    {                                                                        \
        Set8_insert( &( me_ )->super,                                        \
                      ( uint8_t )( Pwr2_div8Lkup[( n_ )] + ( uint8_t )1 ) ); \
        Set8_insert( &( me_ )->subset[Pwr2_div8Lkup[( n_ )]], ( n_ ) );      \
    } while( 0 )

//*****************************************************************************
/// \brief Удалить элемент \a n_ в приоритетной очереди \a me_, \a n_ = 1..64.
/// \param me_ - объект очередь типа Set64_t;
/// \param n_ – идентификатор элемента очереди.
///
#define Set64_remove( me_, n_ )                                                 \
    do                                                                          \
    {                                                                           \
        if( Set8_remove( &( me_ )->subset[Pwr2_div8Lkup[( n_ )]], ( n_ ) )      \
            == ( uint8_t )0 )                                                   \
        {                                                                       \
            Set8_remove( &( me_ )->super,                                       \
                         ( uint8_t )( Pwr2_div8Lkup[( n_ )] + ( uint8_t )1 ) ); \
        }                                                                       \
    } while( 0 )

//*****************************************************************************
/// \brief Поиск элемента с наивысшим приоритетом в очереди \a me_ и 
/// сохранение его значение в \a n_.
/// \param me_ - объект очередь типа Set64_t;
/// \param n_ – идентификатор элемента очереди.
/// \details Если очередь \a me_ пуста, в \a n_ будет записан ноль.
///
#define Set64_findMax( me_, n_ )                                         \
    do                                                                   \
    {                                                                    \
        if( Set64_notEmpty( me_ ) )                                      \
        {                                                                \
            ( n_ ) = ( uint8_t )( LOG2( ( me_ )->super.bits )            \
                             - ( uint8_t )1 );                           \
            ( n_ ) = ( uint8_t )( LOG2( ( me_ )->subset[( n_ )].bits )   \
                             + ( uint8_t )( ( n_ ) << 3 ) );             \
        }                                                                \
        else                                                             \
        {                                                                \
           ( n_ ) = ( uint8_t )0;                                        \
        }                                                                \
    } while( 0 )

//*****************************************************************************
/// \brief Очистка очереди \a me_.
/// \param me_ - объект очередь типа Set64_t.
///
#define Set64_clear( me_ )                                                                                             \
    do                                                                                                                 \
    {                                                                                                                  \
        for( ( me_ )->super.bits = 0; ( me_ )->super.bits < sizeof( ( me_ )->subset ); ( me_ )->super.bits++ )         \
        {                                                                                                              \
            ( me_ )->subset[( me_ )->super.bits].bits = 0;                                                             \
        }                                                                                                              \
    ( me_ )->super.bits = 0;                                                                                           \
    } while( 0 )

//*****************************************************************************
/// \brief Копирование всех элементов очереди \a source_ в очередь \a dest_.
/// \param dest_ - объект очередь типа Set64_t в который копируются элементы;
/// \param source_ – объект очередь типа Set64_t из которого копируются элементы.
///
#define Set64_copy( dest_, source_ )                                                                   \
    do                                                                                                 \
    {                                                                                                  \
        if( ( source_ )->super.bits > 0 )                                                              \
        {                                                                                              \
            for( ( dest_ )->super.bits = 0; ( dest_ )->super.bits < sizeof( ( dest_ )->subset );       \
                 ( dest_ )->super.bits++ )                                                             \
            {                                                                                          \
                ( dest_ )->subset[( dest_ )->super.bits].bits = ( source_ )->subset[( dest_ )->        \
                    super.bits].bits;                                                                  \
            }                                                                                          \
            ( dest_ )->super.bits = ( source_ )->super.bits;                                           \
        }                                                                                              \
        else                                                                                           \
        {                                                                                              \
            Set64_clear( ( dest_ ) );                                                                  \
        }                                                                                              \
} while( 0 )

//*****************************************************************************
// Объявление типов данных
//*****************************************************************************

/****************************************************************************/
/// \brief Очередь с приоритетом из 8 элементов.
/// \details Очередь представляет собой набор элементов. Каждому элементу соответствует
/// свой уровень приоритета. Очередь способна хранить до 8 уровней приоритетов.
/// \note Не допускается хранение двух элементов с одинаковым уровнем приоритета.
///
typedef struct Set8Tag
{
    uint8_t bits; ///< Битовая маска, представляющая элементы очереди. 
} Set8_t;

#endif

//*****************************************************************************
/// \brief Очередь с приоритетом из 64 элементов.
/// \note Очередь представляет собой набор элементов. Каждому элементу соответствует
/// свой уровень приоритета. Очередь способна хранить до 64 уровней приоритетов.
/// \note Не допускается хранение двух элементов с одинаковым уровнем приоритета.
///
typedef struct Set64Tag
{
    
    /// \brief 8-битовый корень очереди, содержащий приоритеты для 8-битовых 
    /// очередей.
    /// \note Каждый бит в super.bits определяет очередь из 8-ми 
    /// элементов:
    ///     - бит 0 в super.bits установлен, когда subset[0] не пуста;
    ///     - бит 1 в super.bits установлен, когда subset[1] не пуста;
    ///     - бит 2 в super.bits установлен, когда subset[2] не пуста;
    ///     - бит 3 в super.bits установлен, когда subset[3] не пуста;
    ///     - бит 4 в super.bits установлен, когда subset[4] не пуста;
    ///     - бит 5 в super.bits установлен, когда subset[5] не пуста;
    ///     - бит 6 в super.bits установлен, когда subset[6] не пуста;
    ///     - бит 7 в super.bits установлен, когда subset[7] не пуста.
    ///
    Set8_t super; // QPSet64 наследуется от QPSet8

    /// \brief Определение элементов.
    /// \note Очередь определяет элементы в очереди как:
    ///     - subset[0] представляет элементы 1..8;
    ///     - subset[1] представляет элементы 9..16;
    ///     - subset[2] представляет элементы 17..24;
    ///     - subset[3] представляет элементы 25..32;
    ///     - subset[4] представляет элементы 33..40;
    ///     - subset[5] представляет элементы 41..48;
    ///     - subset[6] представляет элементы 49..56;
    ///     - subset[7] представляет элементы 57..64.
    ///
    Set8_t subset[8];
} Set64_t;

//*****************************************************************************
/**
* История изменений: 
*
* Версия 1.0.1
* Дата   12-06-2013
* Автор  Годунок А.Н.
* 
* Изменения:
*    Базовая версия.
*
* Версия 1.0.2
* Дата   14-05-2019
* Автор  Годунок А.Н.
* 
* Изменения:
*     Исправлена ошибка в макросе Set8_findMax. 
*     Макроопределение QF_LOG2 заменено на LOG2.
*     Исправлено имя тега в структуре Set64_t.
*/
